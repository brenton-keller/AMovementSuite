; Left Ctrl + Right Mouse Button
^RButton::{
    global scalingModeActive, widthScalingEnabled

    if (scalingModeActive)
        return

    scalingModeActive := true

    if (!widthScalingEnabled) {
        scalingModeActive := false
        return
    }
        
    MouseGetPos ,, &mwin
    
    ; Check if it's a valid window for resizing
    if (!IsValidWindowForResize(mwin)) {
        scalingModeActive := false
        return
    }

    MouseGetPos &startX, &startY, &mwin
    WinGetPos &wx, &wy, &ww, &wh, "ahk_id " mwin

    monitorIndex := GetWindowMonitor(wx, wy, ww, wh)
    MonitorGet(monitorIndex, &monLeft, &monTop, &monRight, &monBottom)
    MonitorGetWorkArea(monitorIndex, &workLeft, &workTop, &workRight, &workBottom)

    initialW := ww
    initialX := wx
    rightEdgePos := wx + ww  ; Store original right edge position
    
    snapEdgeThreshold := 50  ; Pixels from edge to trigger snap
    
    ; Calculate the 1/8 threshold for edge detection
    edgeThreshold := initialW / 8
    
    ; Determine if mouse is near the edges - this mode will be maintained throughout the drag
    isNearLeftEdge := (startX - wx) <= edgeThreshold
    isNearRightEdge := (wx + ww - startX) <= edgeThreshold

    maxWidth := workRight - workLeft
    if (maxWidth <= initialW) {
        maxWidth := initialW + 1  ; Add 1 pixel buffer to prevent division by zero
    }

    relativeX := (startX - wx) / initialW

    ; Create preview GUI
    previewGui := Gui("+ToolWindow -Caption +AlwaysOnTop +E0x20")
    previewGui.BackColor := "22B14C"  ; Same nice green as previous version
    WinSetTransparent 75, previewGui.Hwnd
    previewGui.Show("x" wx " y" wy " w" ww " h" wh " NoActivate")

    While true
    {
        if !GetKeyState("RButton", "P") || !GetKeyState("LControl", "P")
            break

        MouseGetPos &currentX, &currentY
        
        ; Check for monitor changes during drag
        newMonitorIndex := MonitorFromPoint(currentX, currentY)
        if (newMonitorIndex != monitorIndex) {
            monitorIndex := newMonitorIndex
            MonitorGet(monitorIndex, &monLeft, &monTop, &monRight, &monBottom)
            MonitorGetWorkArea(monitorIndex, &workLeft, &workTop, &workRight, &workBottom)
            
            maxWidth := workRight - workLeft
            if (maxWidth <= initialW) {
                maxWidth := initialW + 1
            }
        }

        deltaX := currentX - startX
        
        ; Calculate new dimensions based on the edge detection mode
        if (isNearLeftEdge) {
            ; LEFT EDGE ONLY MODE: Right edge stays fixed
            newX := initialX + deltaX
            
            ; Constrain left edge from moving beyond right edge
            newX := Min(newX, rightEdgePos - Colors.MIN_WIDTH)
            
            ; Constrain left edge from moving beyond screen left
            newX := Max(newX, workLeft)
            
            ; Calculate width based on fixed right edge
            newW := rightEdgePos - newX
        } 
        else if (isNearRightEdge) {
            ; RIGHT EDGE ONLY MODE: Left edge stays fixed
            newX := initialX  ; Keep left position fixed
            
            ; Calculate width based on mouse position
            newW := initialW + deltaX
            
            ; Constrain width so right edge doesn't exceed screen right
            newW := Min(newW, workRight - initialX)
            
            ; Ensure minimum width
            newW := Max(newW, Colors.MIN_WIDTH)
        }
        else {
            ; PROPORTIONAL MODE: Both edges can move
            ; Check if mouse is near screen edge for snapping
            if (currentX >= workRight - snapEdgeThreshold) {
                ; Snap to max width
                newW := maxWidth
                newX := workLeft
            }
            else {
                ; Dynamic sensitivity based on target width
                if (deltaX < 0) {
                    ; For reduction (moving mouse left)
                    scaleFactor := 1 + (deltaX * 0.003)
                } else {
                    ; For expansion (moving mouse right)
                    scaleFactor := 1 + (deltaX * 0.003)
                }
                scaleFactor := Max(0.25, scaleFactor)
                
                newW := Round(initialW * scaleFactor)
                newW := Max(Colors.MIN_WIDTH, Min(newW, maxWidth))
                
                ; Apply proportional positioning
                ; newX := Round(startX - (newW * relativeX))
                ; newX := Max(workLeft, Min(workRight - newW, newX))
                newX := Round(initialX - (newW - initialW) * (1 - relativeX))
                newX := Max(workLeft, Min(workRight - newW, newX))
            }
        }

        ; Update preview color based on new width
        newColor := CalculateColorWidth(newW, initialW, maxWidth)
        previewGui.BackColor := newColor

        ; Update preview
        WinMove newX, wy, newW, wh, previewGui.Hwnd
        WinSetRegion "0-0 w" newW " h" wh, previewGui.Hwnd
    }

    ; Apply final size and destroy preview
    previewGui.Destroy()
    if (IsSet(newW) && IsSet(newX))
    {
        ; Check if window is maximized
        isMaximized := WinGetMinMax("ahk_id " mwin)
        
        if (isMaximized = 1) ; 1 means maximized
        {
            ; Restore the window first
            WinRestore "ahk_id " mwin
            ; Small sleep to ensure the restore completes
            Sleep 10
        }
        
        ; Apply new dimensions
        WinMove newX, wy, newW, wh, "ahk_id " mwin
        
        ; Force a refresh to prevent visual artifacts
        WinHide "ahk_id " mwin
        WinShow "ahk_id " mwin
    }
    
    scalingModeActive := false
}
