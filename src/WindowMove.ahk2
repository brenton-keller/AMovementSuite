#Requires AutoHotkey v2.0
#SingleInstance Force

SetWinDelay -1
SetControlDelay -1
CoordMode "Mouse", "Screen"

; Status indicators for snapping (can be disabled in production)
ShowSnapIndicator(message) {
    ToolTip message, , , 1
    SetTimer () => ToolTip("", , , 1), -1000
}

global positioningGui := ""

<!RButton::  ; LEFT Alt + Right Mouse Button (window moving)
{
    global enableWindowSnapping, positioningGui

    ; Check if functionality is enabled
    if (!windowMoveEnabled)
        return
        
    MouseGetPos &startX, &startY, &mwin
    
    ; Check if it's a valid window for moving
    if (!IsValidWindowForMove(mwin)) {
        return
    }
    
    ; Check if window is maximized
    isMaximized := WinGetMinMax("ahk_id " mwin)
    if (isMaximized = 1) {
        WinRestore "ahk_id " mwin
        Sleep 10  ; Ensure restore completes
    }
    
    WinGetPos &initialWX, &initialWY, &winWidth, &winHeight, "ahk_id " mwin
    
    ; Get the monitor the window is primarily on
    primaryMonitor := GetWindowMonitor(initialWX, initialWY, winWidth, winHeight)
    MonitorGetWorkArea(primaryMonitor, &MonitorWorkAreaLeft, &MonitorWorkAreaTop, &MonitorWorkAreaRight, &MonitorWorkAreaBottom)
    
    ; Calculate initial offset between mouse and window position
    offsetX := startX - initialWX
    offsetY := startY - initialWY
    
    ; Track last snap position for status indicator
    lastSnapPosition := ""
    
    ; Track last S key state to show status only on changes
    lastSKeyState := false
    
    ; Get all other window edges for snapping
    windowEdges := GetWindowEdges(mwin)
       
    ; Add these variables before the While loop
    zWasPressed := false
    guiShown := false

    While (GetKeyState("RButton", "P") && GetKeyState("LAlt", "P"))
    {
        ; Check Snapping key state - snapping only enabled when key is toggled
        currentSKeyState := GetKeyState("1", "P")
        
        ; Toggle snapping when S is pressed (transition from up to down)
        if (currentSKeyState && !lastSKeyState) {
            enableWindowSnapping := !enableWindowSnapping
            if (enableWindowSnapping)
                ShowSnapIndicator("Snapping: Enabled (toggled on)")
            else
                ShowSnapIndicator("Snapping: Disabled (toggled off)")
        }

        ; Update last key state
        lastSKeyState := currentSKeyState
        
        MouseGetPos &currentX, &currentY
        
        ; Calculate new window position directly from current mouse position
        newX := Round(currentX - offsetX)
        newY := Round(currentY - offsetY)
        
        ; Get the monitor for the new position
        currentMonitor := GetWindowMonitor(newX, newY, winWidth, winHeight)
        MonitorGetWorkArea(currentMonitor, &MonitorWorkAreaLeft, &MonitorWorkAreaTop, &MonitorWorkAreaRight, &MonitorWorkAreaBottom)

        ; Check for Z key press
        if (GetKeyState("z", "P")) {
            if (!zWasPressed) {
                zWasPressed := true
                ; Get current cursor position to show GUI under cursor
                MouseGetPos &cursorX, &cursorY
                ShowWindowPositioningGUI(mwin, cursorX, cursorY)
                guiShown := true
            }
        } else {
            zWasPressed := false
        }

        ; Reset snap position
        currentSnapPosition := ""
        
        ; Check for edge snapping (hold Ctrl to temporarily disable)
        if (!GetKeyState("Ctrl", "P"))
        {
            ; Try window edge snapping first (prioritized over screen edges)
            if (enableWindowSnapping) {
                windowSnapResult := ProcessWindowSnapping(newX, newY, winWidth, winHeight, windowEdges)
                if (windowSnapResult.snapped) {
                    newX := windowSnapResult.x
                    newY := windowSnapResult.y
                    currentSnapPosition := windowSnapResult.message
                }
                else  ; If no window snapping, try screen edges
                {
                    screenSnapResult := ProcessScreenSnapping(newX, newY, winWidth, winHeight, 
                        MonitorWorkAreaLeft, MonitorWorkAreaTop, MonitorWorkAreaRight, MonitorWorkAreaBottom)
                    
                    if (screenSnapResult.snapped) {
                        newX := screenSnapResult.x
                        newY := screenSnapResult.y
                        currentSnapPosition := screenSnapResult.message
                    }
                }
            }
        }
        
        ; Constrain to screen boundaries
        newX := Max(MonitorWorkAreaLeft - 1, Min(MonitorWorkAreaRight - winWidth + 1, newX))
        newY := Max(MonitorWorkAreaTop - 1, Min(MonitorWorkAreaBottom - winHeight + 1, newY))
        
        ; Move the window
        WinMove newX, newY, , , "ahk_id " mwin
        
        ; Update snap indicator if position changed and S is being held
        if (enableWindowSnapping) {
            if (currentSnapPosition && currentSnapPosition != lastSnapPosition) {
                ShowSnapIndicator("Snap: " currentSnapPosition)
                lastSnapPosition := currentSnapPosition
            } else if (!currentSnapPosition && lastSnapPosition) {
                ToolTip("", , , 1)  ; Clear tooltip
                lastSnapPosition := ""
            }
        } else if (lastSnapPosition) {
            ; Clear snap indicators when S is released
            ToolTip("", , , 1)
            lastSnapPosition := ""
        }
    }
    
    ; Clear tooltip
    ToolTip("", , , 1)

    ; Check if we need to activate a button based on release position
    if (guiShown && IsObject(positioningGui)) {
        MouseGetPos &releaseX, &releaseY, &mouseWin, &mouseCtrl
        
        ; Check if mouse is over the GUI window
        if (mouseWin == positioningGui.Hwnd && mouseCtrl) {
            ; Safer approach - look up the control directly from the GUI
            try {
                ; Get the control object from the GUI
                ctrl := positioningGui[mouseCtrl]
                if (ctrl) {
                    ; Activate the button
                    ButtonClick(ctrl)
                }
            } catch {
                ; Nothing to do if control lookup fails
            }
        }
        
        ; Always destroy the GUI
        positioningGui.Destroy()
        positioningGui := ""
    }

    DllCall("SetWindowPos", "Ptr", mwin, "Ptr", 0, "Int", 0, "Int", 0, 
            "Int", 0, "Int", 0, "UInt", 0x0001|0x0002|0x0004|0x0400)
}

; Updated button click function
ButtonClick(ctrl, *) {
    global positioningGui
    
    if (!IsObject(positioningGui) || !positioningGui.mwin)
        return
        
    buttonText := ctrl.Text
    mwin := positioningGui.mwin
    
    ; Get window dimensions and position
    WinGetPos &winX, &winY, &winWidth, &winHeight, "ahk_id " mwin
    
    ; Determine which monitor the window is on
    currentMonitor := GetWindowMonitor(winX, winY, winWidth, winHeight)
    MonitorGetWorkArea(currentMonitor, &monitorLeft, &monitorTop, &monitorRight, &monitorBottom)
    
    ; Calculate monitor width and height
    monitorWidth := monitorRight - monitorLeft
    monitorHeight := monitorBottom - monitorTop
    
    ; Position based on button clicked
    if (buttonText = "Left 50%") {
        newX := monitorLeft
        newY := monitorTop
        newWidth := monitorWidth / 2
        newHeight := monitorHeight
        ToolTip("Snapping to left 50%", , , 2)
    } 
    else if (buttonText = "Right 50%") {
        newX := monitorLeft + (monitorWidth / 2)
        newY := monitorTop
        newWidth := monitorWidth / 2
        newHeight := monitorHeight
        ToolTip("Snapping to right 50%", , , 2)
    }
    else if (buttonText = "Left 25%") {
        newX := monitorLeft
        newY := monitorTop
        newWidth := monitorWidth / 4
        newHeight := monitorHeight
        ToolTip("Snapping to left 25%", , , 2)
    }
    else if (buttonText = "Middle 50%") {
        newX := monitorLeft + (monitorWidth / 4)
        newY := monitorTop
        newWidth := monitorWidth / 2
        newHeight := monitorHeight
        ToolTip("Snapping to middle 50%", , , 2)
    }
    else if (buttonText = "Right 25%") {
        newX := monitorLeft + (monitorWidth * 0.75)
        newY := monitorTop
        newWidth := monitorWidth / 4
        newHeight := monitorHeight
        ToolTip("Snapping to right 25%", , , 2)
    }
    else if (buttonText = "Left 33%") {
        newX := monitorLeft
        newY := monitorTop
        newWidth := monitorWidth / 3
        newHeight := monitorHeight
        ToolTip("Snapping to left 33%", , , 2)
    }
    else if (buttonText = "Middle 33%") {
        newX := monitorLeft + (monitorWidth / 3)
        newY := monitorTop
        newWidth := monitorWidth / 3
        newHeight := monitorHeight
        ToolTip("Snapping to middle 33%", , , 2)
    }
    else if (buttonText = "Right 33%") {
        newX := monitorLeft + (monitorWidth * 2/3)
        newY := monitorTop
        newWidth := monitorWidth / 3
        newHeight := monitorHeight
        ToolTip("Snapping to right 33%", , , 2)
    }
    
    ; Move and resize the window
    WinMove newX, newY, newWidth, newHeight, "ahk_id " mwin
    
    ; Clear tooltip after a short delay
    SetTimer () => ToolTip("", , , 2), -1000
}

; Left Shift + Left Alt + Right Mouse Button to move snapped windows together
<+<!RButton::  ; LEFT Shift + LEFT Alt + Right Mouse Button (multi-window moving)
{
    global enableWindowSnapping, positioningGui

    MouseGetPos &startX, &startY, &mwin
    
    ; Check if it's a valid window for moving
    if (!IsValidWindowForMove(mwin)) {
        return
    }
    
    ; Check if window is maximized
    isMaximized := WinGetMinMax("ahk_id " mwin)
    if (isMaximized = 1) {
        WinRestore "ahk_id " mwin
        Sleep 10  ; Ensure restore completes
    }
    
    WinGetPos &initialWX, &initialWY, &winWidth, &winHeight, "ahk_id " mwin
    
    ; Get the monitor the window is primarily on
    primaryMonitor := GetWindowMonitor(initialWX, initialWY, winWidth, winHeight)
    MonitorGetWorkArea(primaryMonitor, &MonitorWorkAreaLeft, &MonitorWorkAreaTop, &MonitorWorkAreaRight, &MonitorWorkAreaBottom)
    
    ; Calculate initial offset between mouse and window position
    offsetX := startX - initialWX
    offsetY := startY - initialWY
    
    ; Get all window edges for snapping detection
    allWindowEdges := GetWindowEdges(mwin)
    
    ; Find snapped windows (windows with edges very close to our target window)
    snappedWindows := FindSnappedWindows(mwin, initialWX, initialWY, winWidth, winHeight, allWindowEdges)
    
    ; If no windows are snapped, show indicator
    if (snappedWindows.Length == 0) {
        ShowSnapIndicator("No snapped windows detected - moving single window")
    } else {
        ShowSnapIndicator("Moving " snappedWindows.Length + 1 " windows together")
    }
    
    ; Store initial positions of all snapped windows
    snappedWindowsInitialPositions := []
    for idx, snapWin in snappedWindows {
        WinGetPos &wx, &wy, &ww, &wh, "ahk_id " snapWin
        snappedWindowsInitialPositions.Push({hwnd: snapWin, x: wx, y: wy, w: ww, h: wh})
    }
    
    While (GetKeyState("RButton", "P") && GetKeyState("LAlt", "P") && GetKeyState("LShift", "P"))
    {
        MouseGetPos &currentX, &currentY
        
        ; Calculate new position for main window
        newX := Round(currentX - offsetX)
        newY := Round(currentY - offsetY)
        
        ; Calculate movement delta
        deltaX := newX - initialWX
        deltaY := newY - initialWY
        
        ; Get the monitor for the new position
        currentMonitor := GetWindowMonitor(newX, newY, winWidth, winHeight)
        MonitorGetWorkArea(currentMonitor, &MonitorWorkAreaLeft, &MonitorWorkAreaTop, &MonitorWorkAreaRight, &MonitorWorkAreaBottom)
        
        ; Constrain main window to screen boundaries
        newX := Max(MonitorWorkAreaLeft - 1, Min(MonitorWorkAreaRight - winWidth + 1, newX))
        newY := Max(MonitorWorkAreaTop - 1, Min(MonitorWorkAreaBottom - winHeight + 1, newY))
        
        ; Recalculate actual delta after constraints
        actualDeltaX := newX - initialWX
        actualDeltaY := newY - initialWY
        
        ; Move the main window
        WinMove newX, newY, , , "ahk_id " mwin
        
        ; Move all snapped windows by the same delta
        for idx, winInfo in snappedWindowsInitialPositions {
            snapNewX := winInfo.x + actualDeltaX
            snapNewY := winInfo.y + actualDeltaY
            
            ; Optionally constrain snapped windows to their respective monitors
            ; This is a design decision - you might want them to be able to move off-screen
            snapMonitor := GetWindowMonitor(snapNewX, snapNewY, winInfo.w, winInfo.h)
            MonitorGetWorkArea(snapMonitor, &snapMonLeft, &snapMonTop, &snapMonRight, &snapMonBottom)
            
            snapNewX := Max(snapMonLeft - 1, Min(snapMonRight - winInfo.w + 1, snapNewX))
            snapNewY := Max(snapMonTop - 1, Min(snapMonBottom - winInfo.h + 1, snapNewY))
            
            WinMove snapNewX, snapNewY, , , "ahk_id " winInfo.hwnd
        }
    }
    
    ; Clear tooltip
    ToolTip("", , , 1)
}
