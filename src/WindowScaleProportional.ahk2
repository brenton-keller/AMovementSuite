#Requires AutoHotkey v2.0
#SingleInstance Force

SetWinDelay -1
SetControlDelay -1
CoordMode "Mouse", "Screen"

resizeActive := false
rButtonReleased := true
wasResizing := false

SetTimer CheckKeysAndResize, 16

CheckKeysAndResize() {
    global resizeActive, rButtonReleased, wasResizing
    
    ; Check if RButton is released
    if (!GetKeyState("RButton", "P")) {
        if (wasResizing) {
            wasResizing := false
            KeyWait "RButton"
            return
        }
        rButtonReleased := true
        resizeActive := false
        return
    }
    
    ; Check if all three keys are pressed
    if (GetKeyState("LControl", "P") && GetKeyState("LShift", "P") && GetKeyState("RButton", "P")) {
        if (!resizeActive && rButtonReleased) {
            ; Get the window under the mouse
            MouseGetPos ,, &mwin
            
            ; Check if it's a valid window for resizing
            if (!IsValidWindowForResize(mwin)) {
                return
            }
            
            wasResizing := true
            rButtonReleased := false
            resizeActive := true
            BlockInput "On"
            StartResize()
            BlockInput "Off"
        }
    }
}

StartResize() {
    ; Check if functionality is enabled
    if (!xyScalingEnabled)
        return

    MouseGetPos &startX, &startY, &mwin
    WinGetPos &wx, &wy, &ww, &wh, "ahk_id " mwin

    ; Determine which monitor the window is on
    currentMonitor := GetWindowMonitor(wx, wy, ww, wh)
    MonitorGet(currentMonitor, &MonLeft, &MonTop, &MonRight, &MonBottom)
    MonitorGetWorkArea(currentMonitor, &WorkAreaLeft, &WorkAreaTop, &WorkAreaRight, &WorkAreaBottom)

    ; Store initial window position and size
    initialW := ww
    initialH := wh
    initialX := wx
    initialY := wy

    ; Calculate relative position of mouse in window
    relativeX := (startX - wx) / ww
    relativeY := (startY - wy) / wh

    ; Calculate maximum allowed dimensions
    maxWidth := MonRight - MonLeft
    maxHeight := MonBottom - MonTop

    ; Create preview GUI
    previewGui := Gui("+ToolWindow -Caption +AlwaysOnTop +E0x20")
    previewGui.BackColor := "22B14C"
    WinSetTransparent 75, previewGui.Hwnd
    previewGui.Show("x" wx " y" wy " w" ww " h" wh " NoActivate")

    While (GetKeyState("RButton", "P") && GetKeyState("LControl", "P") && GetKeyState("LShift", "P"))
    {
        MouseGetPos &currentX, &currentY
        
        ; Determine current monitor
        currentMonitor := GetMonitorAtPos(currentX, currentY)
        MonitorGet(currentMonitor, &MonLeft, &MonTop, &MonRight, &MonBottom)
        MonitorGetWorkArea(currentMonitor, &WorkAreaLeft, &WorkAreaTop, &WorkAreaRight, &WorkAreaBottom)
        
        ; Update maximum dimensions
        maxWidth := MonRight - MonLeft
        maxHeight := MonBottom - MonTop
        
        ; Calculate from initial position
        movement := currentX - startX
        
        ; Scaling factor
        scaleFactor := 1 + (movement * 0.003)
        scaleFactor := Max(0.1, scaleFactor)
        
        ; Calculate new dimensions
        newW := Round(initialW * scaleFactor)
        newH := Round(initialH * scaleFactor)
        
        ; Constrain dimensions
        newW := Min(maxWidth + 2, newW + 2)
        newH := Min(maxHeight + 2, newH + 2)
        
        ; Calculate new position
        newX := Round(startX - (newW * relativeX))
        newY := Round(startY - (newH * relativeY))
        
        ; Constrain position
        newX := Max(MonLeft - 1, Min(MonRight - newW + 1, newX))
        newY := Max(MonTop - 1, Min(MonBottom - newH + 1, newY))
        
        ; Update preview
        WinMove newX, newY, newW, newH, previewGui.Hwnd
        WinSetRegion "0-0 w" newW " h" newH, previewGui.Hwnd
    }

    ; Apply final size and destroy preview
    previewGui.Destroy()
    if (IsSet(newW) && IsSet(newH))
    {
        ; Check if window is maximized
        isMaximized := WinGetMinMax("ahk_id " mwin)
        
        if (isMaximized = 1) ; 1 means maximized
        {
            ; Restore the window first
            WinRestore "ahk_id " mwin
            ; Small sleep to ensure the restore completes
            Sleep 10
        }
        
        ; Apply new dimensions
        WinMove newX, newY, newW, newH, "ahk_id " mwin
        
        ; Force a refresh to prevent visual artifacts
        WinHide "ahk_id " mwin
        WinShow "ahk_id " mwin
    }
    resizeActive := false
}

; Block the normal right-click behavior when modifiers are held
*RButton::
{
    if (GetKeyState("LControl", "P") && GetKeyState("LShift", "P"))
        return
    Click "Right"
}
