#Requires AutoHotkey v2.0
#SingleInstance Force

SetWinDelay -1
SetControlDelay -1
CoordMode "Mouse", "Screen"

debugModeXY := false

resizeActive := false
rButtonReleased := true
wasResizing := false

; State variables for continuous window updating
windowUpdateTimer := 0
targetWindowFrame := {x: 0, y: 0, w: 0, h: 0}  ; Stores desired window position/size
targetWindowID := 0
initialResizeWidth := 0   ; Track original width for auto-update threshold
initialResizeHeight := 0  ; Track original height for auto-update threshold

; State variables for smart updating (change detection)
lastPreviewFrame := {x: 0, y: 0, w: 0, h: 0}   ; Track last preview frame
lastWindowFrame := {x: 0, y: 0, w: 0, h: 0}    ; Track last window frame

; Motion tracking for intelligent window updates
lastFrameChangeTime := 0                        ; Timestamp of last movement

; Timer callback function: Updates the actual window position/size during resize
UpdateActualWindow() {
    global targetWindowFrame, targetWindowID, lastWindowFrame
    global lastFrameChangeTime, MOTION_PAUSE_THRESHOLD
    global initialResizeWidth, initialResizeHeight
    global MIN_AUTO_UPDATE_WIDTH_RATIO, MIN_AUTO_UPDATE_HEIGHT_RATIO

    if (!targetWindowID || !WinExist("ahk_id " targetWindowID))
        return

    ; DIMENSION CHECK: Don't auto-update if window is too small (prevents UI freakout)
    ; Check BOTH width and height against original dimensions
    if (initialResizeWidth > 0 && initialResizeHeight > 0) {
        widthRatio := targetWindowFrame.w / initialResizeWidth
        heightRatio := targetWindowFrame.h / initialResizeHeight

        ; Block auto-update if EITHER dimension is too small
        if (widthRatio < MIN_AUTO_UPDATE_WIDTH_RATIO || heightRatio < MIN_AUTO_UPDATE_HEIGHT_RATIO)
            return  ; Too small, skip auto-update (final update on release still happens)
    }

    ; MOTION CHECK: Only update if we've been stationary for >threshold ms
    ; This prevents window updates during active dragging (only preview updates)
    timeSinceLastChange := A_TickCount - lastFrameChangeTime
    if (timeSinceLastChange < MOTION_PAUSE_THRESHOLD)
        return  ; Still actively moving, skip window update

    ; SMART UPDATE: Only update if frame has actually changed
    if (FramesEqual(targetWindowFrame, lastWindowFrame))
        return  ; No change, skip expensive WinMove operation

    ; Store this frame for next comparison
    lastWindowFrame := {x: targetWindowFrame.x, y: targetWindowFrame.y,
                        w: targetWindowFrame.w, h: targetWindowFrame.h}

    ; Apply the stored frame to the actual window
    WinMove targetWindowFrame.x, targetWindowFrame.y,
            targetWindowFrame.w, targetWindowFrame.h,
            "ahk_id " targetWindowID

    ; Refresh the window (hide/show trick for visual update)
    WinHide "ahk_id " targetWindowID
    WinShow "ahk_id " targetWindowID
}

; Helper function: Check if two frames are equal (for change detection)
FramesEqual(frame1, frame2) {
    return (frame1.x = frame2.x && frame1.y = frame2.y &&
            frame1.w = frame2.w && frame1.h = frame2.h)
}

SetTimer CheckKeysAndResize, 16

CheckKeysAndResize() {
    global resizeActive, rButtonReleased, wasResizing, scalingModeActive
    
    ; If another scaling operation is already active, don't start XY scaling
    if (scalingModeActive)
        return
    
    if (!GetKeyState("RButton", "P")) {
        if (wasResizing) {
            wasResizing := false
            KeyWait "RButton"
            return
        }
        rButtonReleased := true
        resizeActive := false
        return
    }
    
    if (GetKeyState("LControl", "P") && GetKeyState("LShift", "P") && GetKeyState("RButton", "P")) {
        if (!resizeActive && rButtonReleased) {
            MouseGetPos ,, &mwin
            
            if (!IsValidWindowForResize(mwin)) {
                return
            }
            
            wasResizing := true
            rButtonReleased := false
            resizeActive := true
            scalingModeActive := true
            ; BlockInput "On"
            StartResize()
            ; BlockInput "Off"
            scalingModeActive := false
        }
    }
}

StartResize() {
    ; Check if functionality is enabled
    if (!xyScalingEnabled)
        return

    global debugModeXY

    MouseGetPos &startX, &startY, &mwin
    WinGetPos &wx, &wy, &ww, &wh, "ahk_id " mwin

    currentMonitor := GetWindowMonitor(wx, wy, ww, wh)
    MonitorGet(currentMonitor, &MonLeft, &MonTop, &MonRight, &MonBottom)
    MonitorGetWorkArea(currentMonitor, &WorkAreaLeft, &WorkAreaTop, &WorkAreaRight, &WorkAreaBottom)

    initialW := ww
    initialH := wh
    initialX := wx
    initialY := wy

    ; Store initial dimensions for auto-update threshold check
    global initialResizeWidth, initialResizeHeight
    initialResizeWidth := initialW
    initialResizeHeight := initialH

    ; Calculate the 1/8 threshold for edge detection
    edgeThreshold := initialW / 8
    
    ; Determine if mouse is near the edges - this mode will be maintained throughout the drag
    isNearLeftEdge := (startX - wx) <= edgeThreshold
    isNearRightEdge := (wx + ww - startX) <= edgeThreshold
    isNearTopEdge := (startY - wy) <= edgeThreshold
    isNearBottomEdge := (wy + wh - startY) <= edgeThreshold
    
    ; Corner detection
    isNearTopLeft := isNearTopEdge && isNearLeftEdge
    isNearTopRight := isNearTopEdge && isNearRightEdge
    isNearBottomLeft := isNearBottomEdge && isNearLeftEdge
    isNearBottomRight := isNearBottomEdge && isNearRightEdge

    maxWidth := MonRight - MonLeft
    maxHeight := MonBottom - MonTop
    if (maxWidth <= initialW) {
        maxWidth := initialW + 1  ; Add 1 pixel buffer to prevent division by zero
    }
    if (maxHeight <= initialH) {
        maxHeight := initialH + 1  ; Add 1 pixel buffer to prevent division by zero
    }

    relativeX := (startX - wx) / ww
    relativeY := (startY - wy) / wh

    previewGui := Gui("+ToolWindow -Caption +AlwaysOnTop +E0x20")
    if (debugMode) {
        previewGui.BackColor := "0099FF"  ; Static blue color for debugging
    } else {
        previewGui.BackColor := "22B14C"  ; Initial color
    }
    WinSetTransparent 75, previewGui.Hwnd
    previewGui.Show("x" wx " y" wy " w" ww " h" wh " NoActivate")

    ; Initialize continuous window update system
    global targetWindowID, WINDOW_UPDATE_INTERVAL
    targetWindowID := mwin
    SetTimer UpdateActualWindow, WINDOW_UPDATE_INTERVAL

    ; Reset smart update state variables
    global lastPreviewFrame, lastWindowFrame, lastFrameChangeTime, targetWindowFrame
    lastPreviewFrame := {x: wx, y: wy, w: ww, h: wh}
    lastWindowFrame := {x: wx, y: wy, w: ww, h: wh}
    lastFrameChangeTime := A_TickCount
    targetWindowFrame := {x: wx, y: wy, w: ww, h: wh}

    While (GetKeyState("RButton", "P") && GetKeyState("LControl", "P") && GetKeyState("LShift", "P"))
    {
        MouseGetPos &currentX, &currentY

        currentMonitor := GetMonitorAtPos(currentX, currentY)
        MonitorGet(currentMonitor, &MonLeft, &MonTop, &MonRight, &MonBottom)
        MonitorGetWorkArea(currentMonitor, &WorkAreaLeft, &WorkAreaTop, &WorkAreaRight, &WorkAreaBottom)
        
        maxWidth := MonRight - MonLeft
        maxHeight := MonBottom - MonTop

        if (isNearTopLeft) {
            ; Directly resize window with bottom-right fixed
            moveX := currentX - startX
            moveY := currentY - startY
            
            ; Calculate new dimensions directly from movement
            newW := initialW - moveX
            newH := initialH - moveY
            
            ; Enforce minimum dimensions
            newW := Max(100, newW)
            newH := Max(100, newH)
            
            ; Constrain maximum dimensions
            newW := Min(maxWidth + 2, newW + 2)
            newH := Min(maxHeight + 2, newH + 2)
            
            ; Calculate new position (keeping bottom-right fixed)
            newX := initialX + initialW - newW
            newY := initialY + initialH - newH
        } else if (isNearTopRight) {
            ; Directly resize window with bottom-left fixed
            moveX := currentX - startX
            moveY := currentY - startY
            
            ; Calculate new dimensions directly from movement
            newW := initialW + moveX
            newH := initialH - moveY
            
            ; Enforce minimum dimensions
            newW := Max(100, newW)
            newH := Max(100, newH)
            
            ; Constrain maximum dimensions
            newW := Min(maxWidth + 2, newW + 2)
            newH := Min(maxHeight + 2, newH + 2)
            
            ; Calculate new position (keeping bottom-left fixed)
            newX := initialX
            newY := initialY + initialH - newH
        } else if (isNearBottomLeft) {
            ; Directly resize window with top-right fixed
            moveX := currentX - startX
            moveY := currentY - startY
            
            ; Calculate new dimensions directly from movement
            newW := initialW - moveX
            newH := initialH + moveY
            
            ; Enforce minimum dimensions
            newW := Max(100, newW)
            newH := Max(100, newH)
            
            ; Constrain maximum dimensions
            newW := Min(maxWidth + 2, newW + 2)
            newH := Min(maxHeight + 2, newH + 2)
            
            ; Calculate new position (keeping top-right fixed)
            newX := initialX + initialW - newW
            newY := initialY
        } else if (isNearBottomRight) {
            ; Directly resize window with top-left fixed
            moveX := currentX - startX
            moveY := currentY - startY
            
            ; Calculate new dimensions directly from movement
            newW := initialW + moveX
            newH := initialH + moveY
            
            ; Enforce minimum dimensions
            newW := Max(100, newW)
            newH := Max(100, newH)
            
            ; Constrain maximum dimensions
            newW := Min(maxWidth + 2, newW + 2)
            newH := Min(maxHeight + 2, newH + 2)
            
            ; Calculate new position (keeping top-left fixed)
            newX := initialX
            newY := initialY
        } else {
            ; Calculate X and Y movements separately
            moveX := currentX - startX
            moveY := currentY - startY

            ; Calculate scaling factors independently for X and Y
            scaleFactorX := 1 + (moveX * 0.003)
            scaleFactorY := 1 + (-moveY * 0.003)  ; Negative for intuitive up/down scaling

            ; Apply minimum scaling
            scaleFactorX := Max(0.1, scaleFactorX)
            scaleFactorY := Max(0.1, scaleFactorY)

            ; Calculate new dimensions
            newW := Round(initialW * scaleFactorX)
            newH := Round(initialH * scaleFactorY)

            ; Constrain dimensions
            newW := Min(maxWidth + 2, newW + 2)
            newH := Min(maxHeight + 2, newH + 2)

            ; Calculate new position
            newX := Round(startX - (newW * relativeX))
            newY := Round(startY - (newH * relativeY))
        }
        
        ; Constrain position
        newX := Max(MonLeft - 1, Min(MonRight - newW + 1, newX))
        newY := Max(MonTop - 1, Min(MonBottom - newH + 1, newY))

        ; CHANGE DETECTION: Create frame object for comparison
        currentFrame := {x: newX, y: newY, w: newW, h: newH}
        global lastPreviewFrame, lastFrameChangeTime, targetWindowFrame

        ; Check if frame has changed (for motion tracking)
        frameChanged := !FramesEqual(currentFrame, lastPreviewFrame)

        if (frameChanged) {
            lastPreviewFrame := currentFrame
            lastFrameChangeTime := A_TickCount  ; Reset motion timer
            targetWindowFrame := currentFrame   ; Update target for window
            previewGui.Show("NoActivate")  ; Show preview when moving
        } else {
            ; Check if we've been stationary long enough to hide preview
            global MOTION_PAUSE_THRESHOLD, MIN_AUTO_UPDATE_WIDTH_RATIO, MIN_AUTO_UPDATE_HEIGHT_RATIO
            global initialResizeWidth, initialResizeHeight
            timeSinceLastChange := A_TickCount - lastFrameChangeTime

            if (timeSinceLastChange >= MOTION_PAUSE_THRESHOLD) {
                ; Only hide if BOTH dimensions are large enough for auto-update
                ; (Keep preview visible when too small - serves as warning)
                widthRatio := newW / initialResizeWidth
                heightRatio := newH / initialResizeHeight

                if (widthRatio >= MIN_AUTO_UPDATE_WIDTH_RATIO && heightRatio >= MIN_AUTO_UPDATE_HEIGHT_RATIO) {
                    previewGui.Hide()  ; Normal behavior - window auto-updates
                }
                ; If either dimension too small, keep preview visible as visual indicator
            }
        }

        ; ALWAYS update preview position/color (even when hidden, so it's ready when shown)
        if (!debugModeXY) {
            newColor := CalculateColorXY(newW, newH, initialW, initialH, maxWidth, maxHeight)
            previewGui.BackColor := newColor
        }

        WinMove newX, newY, newW, newH, previewGui.Hwnd
        WinSetRegion "0-0 w" newW " h" newH, previewGui.Hwnd
    }

    ; Stop continuous window update timer
    SetTimer UpdateActualWindow, 0

    previewGui.Destroy()

    ; Final window position sync (only if needed to prevent flash)
    if (IsSet(newW) && IsSet(newH))
    {
        ; Check if window is already at target position
        WinGetPos &currentX, &currentY, &currentW, &currentH, "ahk_id " mwin

        ; Only update if not already at target (prevents flash from redundant update)
        if (currentX != newX || currentY != newY || currentW != newW || currentH != newH) {
            isMaximized := WinGetMinMax("ahk_id " mwin)

            if (isMaximized = 1) {
                WinRestore "ahk_id " mwin
                Sleep 10
            }

            ; Final resize (without the hide/show to reduce flash)
            WinMove newX, newY, newW, newH, "ahk_id " mwin
        }
    }
    resizeActive := false
}

*RButton::
{
    if (GetKeyState("LControl", "P") && GetKeyState("LShift", "P"))
        return
    Click "Right"
}
