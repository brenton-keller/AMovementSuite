#Requires AutoHotkey v2.0
#SingleInstance Force

SetWinDelay -1
SetControlDelay -1
CoordMode "Mouse", "Screen"

debugModeXY := false

resizeActive := false
rButtonReleased := true
wasResizing := false

SetTimer CheckKeysAndResize, 16

CheckKeysAndResize() {
    global resizeActive, rButtonReleased, wasResizing, scalingModeActive
    
    ; If another scaling operation is already active, don't start XY scaling
    if (scalingModeActive)
        return
    
    if (!GetKeyState("RButton", "P")) {
        if (wasResizing) {
            wasResizing := false
            KeyWait "RButton"
            return
        }
        rButtonReleased := true
        resizeActive := false
        return
    }
    
    if (GetKeyState("LControl", "P") && GetKeyState("LShift", "P") && GetKeyState("RButton", "P")) {
        if (!resizeActive && rButtonReleased) {
            MouseGetPos ,, &mwin
            
            if (!IsValidWindowForResize(mwin)) {
                return
            }
            
            wasResizing := true
            rButtonReleased := false
            resizeActive := true
            scalingModeActive := true
            ; BlockInput "On"
            StartResize()
            ; BlockInput "Off"
            scalingModeActive := false
        }
    }
}

StartResize() {
    ; Check if functionality is enabled
    if (!xyScalingEnabled)
        return

    global debugModeXY

    MouseGetPos &startX, &startY, &mwin
    WinGetPos &wx, &wy, &ww, &wh, "ahk_id " mwin

    currentMonitor := GetWindowMonitor(wx, wy, ww, wh)
    MonitorGet(currentMonitor, &MonLeft, &MonTop, &MonRight, &MonBottom)
    MonitorGetWorkArea(currentMonitor, &WorkAreaLeft, &WorkAreaTop, &WorkAreaRight, &WorkAreaBottom)

    initialW := ww
    initialH := wh
    initialX := wx
    initialY := wy

    ; Calculate the 1/8 threshold for edge detection
    edgeThreshold := initialW / 8
    
    ; Determine if mouse is near the edges - this mode will be maintained throughout the drag
    isNearLeftEdge := (startX - wx) <= edgeThreshold
    isNearRightEdge := (wx + ww - startX) <= edgeThreshold
    isNearTopEdge := (startY - wy) <= edgeThreshold
    isNearBottomEdge := (wy + wh - startY) <= edgeThreshold
    
    ; Corner detection
    isNearTopLeft := isNearTopEdge && isNearLeftEdge
    isNearTopRight := isNearTopEdge && isNearRightEdge
    isNearBottomLeft := isNearBottomEdge && isNearLeftEdge
    isNearBottomRight := isNearBottomEdge && isNearRightEdge

    maxWidth := MonRight - MonLeft
    maxHeight := MonBottom - MonTop
    if (maxWidth <= initialW) {
        maxWidth := initialW + 1  ; Add 1 pixel buffer to prevent division by zero
    }
    if (maxHeight <= initialH) {
        maxHeight := initialH + 1  ; Add 1 pixel buffer to prevent division by zero
    }

    relativeX := (startX - wx) / ww
    relativeY := (startY - wy) / wh

    previewGui := Gui("+ToolWindow -Caption +AlwaysOnTop +E0x20")
    if (debugMode) {
        previewGui.BackColor := "0099FF"  ; Static blue color for debugging
    } else {
        previewGui.BackColor := "22B14C"  ; Initial color
    }
    WinSetTransparent 75, previewGui.Hwnd
    previewGui.Show("x" wx " y" wy " w" ww " h" wh " NoActivate")

    While (GetKeyState("RButton", "P") && GetKeyState("LControl", "P") && GetKeyState("LShift", "P"))
    {
        MouseGetPos &currentX, &currentY
        
        currentMonitor := GetMonitorAtPos(currentX, currentY)
        MonitorGet(currentMonitor, &MonLeft, &MonTop, &MonRight, &MonBottom)
        MonitorGetWorkArea(currentMonitor, &WorkAreaLeft, &WorkAreaTop, &WorkAreaRight, &WorkAreaBottom)
        
        maxWidth := MonRight - MonLeft
        maxHeight := MonBottom - MonTop

        if (isNearTopLeft) {
            ; Directly resize window with bottom-right fixed
            moveX := currentX - startX
            moveY := currentY - startY
            
            ; Calculate new dimensions directly from movement
            newW := initialW - moveX
            newH := initialH - moveY
            
            ; Enforce minimum dimensions
            newW := Max(100, newW)
            newH := Max(100, newH)
            
            ; Constrain maximum dimensions
            newW := Min(maxWidth + 2, newW + 2)
            newH := Min(maxHeight + 2, newH + 2)
            
            ; Calculate new position (keeping bottom-right fixed)
            newX := initialX + initialW - newW
            newY := initialY + initialH - newH
        } else if (isNearTopRight) {
            ; Directly resize window with bottom-left fixed
            moveX := currentX - startX
            moveY := currentY - startY
            
            ; Calculate new dimensions directly from movement
            newW := initialW + moveX
            newH := initialH - moveY
            
            ; Enforce minimum dimensions
            newW := Max(100, newW)
            newH := Max(100, newH)
            
            ; Constrain maximum dimensions
            newW := Min(maxWidth + 2, newW + 2)
            newH := Min(maxHeight + 2, newH + 2)
            
            ; Calculate new position (keeping bottom-left fixed)
            newX := initialX
            newY := initialY + initialH - newH
        } else if (isNearBottomLeft) {
            ; Directly resize window with top-right fixed
            moveX := currentX - startX
            moveY := currentY - startY
            
            ; Calculate new dimensions directly from movement
            newW := initialW - moveX
            newH := initialH + moveY
            
            ; Enforce minimum dimensions
            newW := Max(100, newW)
            newH := Max(100, newH)
            
            ; Constrain maximum dimensions
            newW := Min(maxWidth + 2, newW + 2)
            newH := Min(maxHeight + 2, newH + 2)
            
            ; Calculate new position (keeping top-right fixed)
            newX := initialX + initialW - newW
            newY := initialY
        } else if (isNearBottomRight) {
            ; Directly resize window with top-left fixed
            moveX := currentX - startX
            moveY := currentY - startY
            
            ; Calculate new dimensions directly from movement
            newW := initialW + moveX
            newH := initialH + moveY
            
            ; Enforce minimum dimensions
            newW := Max(100, newW)
            newH := Max(100, newH)
            
            ; Constrain maximum dimensions
            newW := Min(maxWidth + 2, newW + 2)
            newH := Min(maxHeight + 2, newH + 2)
            
            ; Calculate new position (keeping top-left fixed)
            newX := initialX
            newY := initialY
        } else {
            ; Calculate X and Y movements separately
            moveX := currentX - startX
            moveY := currentY - startY

            ; Calculate scaling factors independently for X and Y
            scaleFactorX := 1 + (moveX * 0.003)
            scaleFactorY := 1 + (-moveY * 0.003)  ; Negative for intuitive up/down scaling

            ; Apply minimum scaling
            scaleFactorX := Max(0.1, scaleFactorX)
            scaleFactorY := Max(0.1, scaleFactorY)

            ; Calculate new dimensions
            newW := Round(initialW * scaleFactorX)
            newH := Round(initialH * scaleFactorY)

            ; Constrain dimensions
            newW := Min(maxWidth + 2, newW + 2)
            newH := Min(maxHeight + 2, newH + 2)

            ; Calculate new position
            newX := Round(startX - (newW * relativeX))
            newY := Round(startY - (newH * relativeY))
        }
        
        ; Constrain position
        newX := Max(MonLeft - 1, Min(MonRight - newW + 1, newX))
        newY := Max(MonTop - 1, Min(MonBottom - newH + 1, newY))
        
        ; Update preview color only if not in debug mode
        if (!debugModeXY) {
            newColor := CalculateColorXY(newW, newH, initialW, initialH, maxWidth, maxHeight)
            previewGui.BackColor := newColor
        }

        ; Update preview
        WinMove newX, newY, newW, newH, previewGui.Hwnd
        WinSetRegion "0-0 w" newW " h" newH, previewGui.Hwnd
    }
    previewGui.Destroy()
    
    if (IsSet(newW) && IsSet(newH))
    {
        isMaximized := WinGetMinMax("ahk_id " mwin)
        
        if (isMaximized = 1)
        {
            WinRestore "ahk_id " mwin
            Sleep 10
        }
        
        WinMove newX, newY, newW, newH, "ahk_id " mwin
        
        WinHide "ahk_id " mwin
        WinShow "ahk_id " mwin
    }
    resizeActive := false
}

*RButton::
{
    if (GetKeyState("LControl", "P") && GetKeyState("LShift", "P"))
        return
    Click "Right"
}
