#Requires AutoHotkey v2.0
#SingleInstance Force

SetWinDelay -1
SetControlDelay -1
CoordMode "Mouse", "Screen"

debugModeXY := false

resizeActive := false
rButtonReleased := true
wasResizing := false

; Timer state tracking for proper cleanup
global xyScalingTimerRunning := false

; State variables for continuous window updating
windowUpdateTimer := 0
targetWindowFrame := {x: 0, y: 0, w: 0, h: 0}  ; Stores desired window position/size
targetWindowID := 0
initialResizeWidth := 0   ; Track original width for auto-update threshold
initialResizeHeight := 0  ; Track original height for auto-update threshold

; State variables for smart updating (change detection)
lastPreviewFrame := {x: 0, y: 0, w: 0, h: 0}   ; Track last preview frame
lastWindowFrame := {x: 0, y: 0, w: 0, h: 0}    ; Track last window frame

; Motion tracking for intelligent window updates
lastFrameChangeTime := 0                        ; Timestamp of last movement

; Timer callback function: Updates the actual window position/size during resize
UpdateActualWindow() {
    global targetWindowFrame, targetWindowID, lastWindowFrame
    global lastFrameChangeTime, MOTION_PAUSE_THRESHOLD
    global initialResizeWidth, initialResizeHeight
    global MIN_AUTO_UPDATE_WIDTH_RATIO, MIN_AUTO_UPDATE_HEIGHT_RATIO

    if (!targetWindowID || !WinExist("ahk_id " targetWindowID))
        return

    ; DIMENSION CHECK: Don't auto-update if window is too small (prevents UI freakout)
    ; Check BOTH width and height against original dimensions
    if (initialResizeWidth > 0 && initialResizeHeight > 0) {
        widthRatio := targetWindowFrame.w / initialResizeWidth
        heightRatio := targetWindowFrame.h / initialResizeHeight

        ; Block auto-update if EITHER dimension is too small
        if (widthRatio < MIN_AUTO_UPDATE_WIDTH_RATIO || heightRatio < MIN_AUTO_UPDATE_HEIGHT_RATIO)
            return  ; Too small, skip auto-update (final update on release still happens)
    }

    ; MOTION CHECK: Only update if we've been stationary for >threshold ms
    ; This prevents window updates during active dragging (only preview updates)
    timeSinceLastChange := A_TickCount - lastFrameChangeTime
    if (timeSinceLastChange < MOTION_PAUSE_THRESHOLD)
        return  ; Still actively moving, skip window update

    ; SMART UPDATE: Only update if frame has actually changed
    if (FramesEqual(targetWindowFrame, lastWindowFrame))
        return  ; No change, skip expensive WinMove operation

    ; Store this frame for next comparison
    lastWindowFrame := {x: targetWindowFrame.x, y: targetWindowFrame.y,
                        w: targetWindowFrame.w, h: targetWindowFrame.h}

    ; Apply the stored frame to the actual window
    WinMove targetWindowFrame.x, targetWindowFrame.y,
            targetWindowFrame.w, targetWindowFrame.h,
            "ahk_id " targetWindowID

    ; Refresh the window (hide/show trick for visual update)
    WinHide "ahk_id " targetWindowID
    WinShow "ahk_id " targetWindowID
}

; Helper function: Check if two frames are equal (for change detection)
FramesEqual(frame1, frame2) {
    return (frame1.x = frame2.x && frame1.y = frame2.y &&
            frame1.w = frame2.w && frame1.h = frame2.h)
}

; Timer starts/stops via ToggleXYScaling() in ToggleUtils.ahk2
; No unconditional SetTimer here - memory leak prevention!

; Initialize timer if feature is enabled by default
if (xyScalingEnabled) {
    SetTimer CheckKeysAndResize, 16
    xyScalingTimerRunning := true
}

CheckKeysAndResize() {
    global resizeActive, rButtonReleased, wasResizing, scalingModeActive, xyScalingEnabled

    ; Early return if feature is disabled - don't waste CPU cycles
    if (!xyScalingEnabled)
        return

    ; If another scaling operation is already active, don't start XY scaling
    if (scalingModeActive)
        return
    
    if (!GetKeyState("RButton", "P")) {
        if (wasResizing) {
            wasResizing := false
            KeyWait "RButton"
            return
        }
        rButtonReleased := true
        resizeActive := false
        return
    }
    
    if (GetKeyState("LControl", "P") && GetKeyState("LShift", "P") && GetKeyState("RButton", "P")) {
        if (!resizeActive && rButtonReleased) {
            MouseGetPos ,, &mwin
            
            if (!IsValidWindowForResize(mwin)) {
                return
            }
            
            wasResizing := true
            rButtonReleased := false
            resizeActive := true
            scalingModeActive := true
            ; BlockInput "On"
            StartResize()
            ; BlockInput "Off"
            scalingModeActive := false
        }
    }
}

StartResize() {
    ; Check if functionality is enabled
    if (!xyScalingEnabled)
        return

    global debugModeXY

    MouseGetPos &startX, &startY, &mwin
    WinGetPos &wx, &wy, &ww, &wh, "ahk_id " mwin

    currentMonitor := GetWindowMonitor(wx, wy, ww, wh)
    VirtualMonitorGet(currentMonitor, &MonLeft, &MonTop, &MonRight, &MonBottom)
    VirtualMonitorGetWorkArea(currentMonitor, &WorkAreaLeft, &WorkAreaTop, &WorkAreaRight, &WorkAreaBottom)

    initialW := ww
    initialH := wh
    initialX := wx
    initialY := wy

    ; Store initial dimensions for auto-update threshold check
    global initialResizeWidth, initialResizeHeight
    initialResizeWidth := initialW
    initialResizeHeight := initialH

    ; Calculate the 1/8 threshold for edge detection
    edgeThreshold := initialW / 8
    
    ; Determine if mouse is near the edges - this mode will be maintained throughout the drag
    isNearLeftEdge := (startX - wx) <= edgeThreshold
    isNearRightEdge := (wx + ww - startX) <= edgeThreshold
    isNearTopEdge := (startY - wy) <= edgeThreshold
    isNearBottomEdge := (wy + wh - startY) <= edgeThreshold
    
    ; Corner detection
    isNearTopLeft := isNearTopEdge && isNearLeftEdge
    isNearTopRight := isNearTopEdge && isNearRightEdge
    isNearBottomLeft := isNearBottomEdge && isNearLeftEdge
    isNearBottomRight := isNearBottomEdge && isNearRightEdge

    maxWidth := MonRight - MonLeft
    maxHeight := MonBottom - MonTop

    relativeX := (startX - wx) / ww
    relativeY := (startY - wy) / wh

    previewGui := Gui("+ToolWindow -Caption +AlwaysOnTop +E0x20")
    if (debugMode) {
        previewGui.BackColor := "0099FF"  ; Static blue color for debugging
    } else {
        previewGui.BackColor := "22B14C"  ; Initial color
    }
    WinSetTransparent 75, previewGui.Hwnd
    previewGui.Show("x" wx " y" wy " w" ww " h" wh " NoActivate")

    ; Initialize continuous window update system
    global targetWindowID, WINDOW_UPDATE_INTERVAL
    targetWindowID := mwin
    SetTimer UpdateActualWindow, WINDOW_UPDATE_INTERVAL

    ; Reset smart update state variables
    global lastPreviewFrame, lastWindowFrame, lastFrameChangeTime, targetWindowFrame
    lastPreviewFrame := {x: wx, y: wy, w: ww, h: wh}
    lastWindowFrame := {x: wx, y: wy, w: ww, h: wh}
    lastFrameChangeTime := A_TickCount
    targetWindowFrame := {x: wx, y: wy, w: ww, h: wh}

    ; Cache monitor bounds to avoid recalculating every frame (performance optimization)
    cachedMonitor := currentMonitor
    cachedMonLeft := MonLeft
    cachedMonTop := MonTop
    cachedMonRight := MonRight
    cachedMonBottom := MonBottom
    cachedWorkLeft := WorkAreaLeft
    cachedWorkTop := WorkAreaTop
    cachedWorkRight := WorkAreaRight
    cachedWorkBottom := WorkAreaBottom
    cachedMaxWidth := maxWidth
    cachedMaxHeight := maxHeight

    While (GetKeyState("RButton", "P") && GetKeyState("LControl", "P") && GetKeyState("LShift", "P"))
    {
        MouseGetPos &currentX, &currentY

        ; Calculate new dimensions first (before monitor check)
        ; We'll use these to determine which monitor the window is on

        if (isNearTopLeft) {
            ; Directly resize window with bottom-right fixed
            moveX := currentX - startX
            moveY := currentY - startY

            ; Calculate new dimensions directly from movement
            newW := initialW - moveX
            newH := initialH - moveY

            ; Enforce minimum dimensions
            newW := Max(100, newW)
            newH := Max(100, newH)

            ; Calculate new position (keeping bottom-right fixed)
            newX := initialX + initialW - newW
            newY := initialY + initialH - newH

            ; Check monitor based on NEW window position
            newMonitor := GetWindowMonitor(newX, newY, newW, newH)
            if (newMonitor != cachedMonitor) {
                VirtualMonitorGet(newMonitor, &cachedMonLeft, &cachedMonTop, &cachedMonRight, &cachedMonBottom)
                VirtualMonitorGetWorkArea(newMonitor, &cachedWorkLeft, &cachedWorkTop, &cachedWorkRight, &cachedWorkBottom)
                cachedMaxWidth := cachedMonRight - cachedMonLeft
                cachedMaxHeight := cachedMonBottom - cachedMonTop
                cachedMonitor := newMonitor
            }

            ; Constrain maximum dimensions to current monitor
            newW := Min(cachedMaxWidth + 2, newW + 2)
            newH := Min(cachedMaxHeight + 2, newH + 2)

            ; Recalculate position after constraint
            newX := initialX + initialW - newW
            newY := initialY + initialH - newH
        } else if (isNearTopRight) {
            ; Directly resize window with bottom-left fixed
            moveX := currentX - startX
            moveY := currentY - startY

            ; Calculate new dimensions directly from movement
            newW := initialW + moveX
            newH := initialH - moveY

            ; Enforce minimum dimensions
            newW := Max(100, newW)
            newH := Max(100, newH)

            ; Calculate new position (keeping bottom-left fixed)
            newX := initialX
            newY := initialY + initialH - newH

            ; Check monitor based on NEW window position
            newMonitor := GetWindowMonitor(newX, newY, newW, newH)
            if (newMonitor != cachedMonitor) {
                VirtualMonitorGet(newMonitor, &cachedMonLeft, &cachedMonTop, &cachedMonRight, &cachedMonBottom)
                VirtualMonitorGetWorkArea(newMonitor, &cachedWorkLeft, &cachedWorkTop, &cachedWorkRight, &cachedWorkBottom)
                cachedMaxWidth := cachedMonRight - cachedMonLeft
                cachedMaxHeight := cachedMonBottom - cachedMonTop
                cachedMonitor := newMonitor
            }

            ; Constrain maximum dimensions to current monitor
            newW := Min(cachedMaxWidth + 2, newW + 2)
            newH := Min(cachedMaxHeight + 2, newH + 2)

            ; Recalculate position after constraint
            newY := initialY + initialH - newH
        } else if (isNearBottomLeft) {
            ; Directly resize window with top-right fixed
            moveX := currentX - startX
            moveY := currentY - startY

            ; Calculate new dimensions directly from movement
            newW := initialW - moveX
            newH := initialH + moveY

            ; Enforce minimum dimensions
            newW := Max(100, newW)
            newH := Max(100, newH)

            ; Calculate new position (keeping top-right fixed)
            newX := initialX + initialW - newW
            newY := initialY

            ; Check monitor based on NEW window position
            newMonitor := GetWindowMonitor(newX, newY, newW, newH)
            if (newMonitor != cachedMonitor) {
                VirtualMonitorGet(newMonitor, &cachedMonLeft, &cachedMonTop, &cachedMonRight, &cachedMonBottom)
                VirtualMonitorGetWorkArea(newMonitor, &cachedWorkLeft, &cachedWorkTop, &cachedWorkRight, &cachedWorkBottom)
                cachedMaxWidth := cachedMonRight - cachedMonLeft
                cachedMaxHeight := cachedMonBottom - cachedMonTop
                cachedMonitor := newMonitor
            }

            ; Constrain maximum dimensions to current monitor
            newW := Min(cachedMaxWidth + 2, newW + 2)
            newH := Min(cachedMaxHeight + 2, newH + 2)

            ; Recalculate position after constraint
            newX := initialX + initialW - newW
        } else if (isNearBottomRight) {
            ; Directly resize window with top-left fixed
            moveX := currentX - startX
            moveY := currentY - startY

            ; Calculate new dimensions directly from movement
            newW := initialW + moveX
            newH := initialH + moveY

            ; Enforce minimum dimensions
            newW := Max(100, newW)
            newH := Max(100, newH)

            ; Calculate new position (keeping top-left fixed)
            newX := initialX
            newY := initialY

            ; Check monitor based on NEW window position
            newMonitor := GetWindowMonitor(newX, newY, newW, newH)
            if (newMonitor != cachedMonitor) {
                VirtualMonitorGet(newMonitor, &cachedMonLeft, &cachedMonTop, &cachedMonRight, &cachedMonBottom)
                VirtualMonitorGetWorkArea(newMonitor, &cachedWorkLeft, &cachedWorkTop, &cachedWorkRight, &cachedWorkBottom)
                cachedMaxWidth := cachedMonRight - cachedMonLeft
                cachedMaxHeight := cachedMonBottom - cachedMonTop
                cachedMonitor := newMonitor
            }

            ; Constrain maximum dimensions to current monitor
            newW := Min(cachedMaxWidth + 2, newW + 2)
            newH := Min(cachedMaxHeight + 2, newH + 2)
        } else {
            ; Proportional mode (not near any edge)
            ; Calculate X and Y movements separately
            moveX := currentX - startX
            moveY := currentY - startY

            ; Calculate scaling factors independently for X and Y
            scaleFactorX := 1 + (moveX * 0.003)
            scaleFactorY := 1 + (-moveY * 0.003)  ; Negative for intuitive up/down scaling

            ; Apply minimum scaling
            scaleFactorX := Max(0.1, scaleFactorX)
            scaleFactorY := Max(0.1, scaleFactorY)

            ; Calculate new dimensions
            newW := Round(initialW * scaleFactorX)
            newH := Round(initialH * scaleFactorY)

            ; Calculate new position
            newX := Round(startX - (newW * relativeX))
            newY := Round(startY - (newH * relativeY))

            ; Check monitor based on NEW window position
            newMonitor := GetWindowMonitor(newX, newY, newW, newH)
            if (newMonitor != cachedMonitor) {
                VirtualMonitorGet(newMonitor, &cachedMonLeft, &cachedMonTop, &cachedMonRight, &cachedMonBottom)
                VirtualMonitorGetWorkArea(newMonitor, &cachedWorkLeft, &cachedWorkTop, &cachedWorkRight, &cachedWorkBottom)
                cachedMaxWidth := cachedMonRight - cachedMonLeft
                cachedMaxHeight := cachedMonBottom - cachedMonTop
                cachedMonitor := newMonitor
            }

            ; Constrain dimensions to current monitor
            newW := Min(cachedMaxWidth + 2, newW + 2)
            newH := Min(cachedMaxHeight + 2, newH + 2)
        }

        ; Constrain position to current monitor (use cached values)
        newX := Max(cachedMonLeft - 1, Min(cachedMonRight - newW + 1, newX))
        newY := Max(cachedMonTop - 1, Min(cachedMonBottom - newH + 1, newY))

        ; CHANGE DETECTION: Create frame object for comparison
        currentFrame := {x: newX, y: newY, w: newW, h: newH}
        global lastPreviewFrame, lastFrameChangeTime, targetWindowFrame

        ; Check if frame has changed (for motion tracking)
        frameChanged := !FramesEqual(currentFrame, lastPreviewFrame)

        if (frameChanged) {
            lastPreviewFrame := currentFrame
            lastFrameChangeTime := A_TickCount  ; Reset motion timer
            targetWindowFrame := currentFrame   ; Update target for window
            previewGui.Show("NoActivate")  ; Show preview when moving
        } else {
            ; Check if we've been stationary long enough to hide preview
            global MOTION_PAUSE_THRESHOLD, MIN_AUTO_UPDATE_WIDTH_RATIO, MIN_AUTO_UPDATE_HEIGHT_RATIO
            global initialResizeWidth, initialResizeHeight
            timeSinceLastChange := A_TickCount - lastFrameChangeTime

            if (timeSinceLastChange >= MOTION_PAUSE_THRESHOLD) {
                ; Only hide if BOTH dimensions are large enough for auto-update
                ; (Keep preview visible when too small - serves as warning)
                widthRatio := newW / initialResizeWidth
                heightRatio := newH / initialResizeHeight

                if (widthRatio >= MIN_AUTO_UPDATE_WIDTH_RATIO && heightRatio >= MIN_AUTO_UPDATE_HEIGHT_RATIO) {
                    previewGui.Hide()  ; Normal behavior - window auto-updates
                }
                ; If either dimension too small, keep preview visible as visual indicator
            }
        }

        ; ALWAYS update preview position/color (even when hidden, so it's ready when shown)
        ; Lock window update to prevent flicker (batch all changes into one redraw)
        DllCall("LockWindowUpdate", "UInt", previewGui.Hwnd)

        if (!debugModeXY) {
            ; Pass maxWidth/maxHeight + 1 to color calc for better gradient (prevents purple at max size)
            newColor := CalculateColorXY(newW, newH, initialW, initialH, maxWidth + 1, maxHeight + 1)
            previewGui.BackColor := newColor
        }

        WinMove newX, newY, newW, newH, previewGui.Hwnd
        WinSetRegion "0-0 w" newW " h" newH, previewGui.Hwnd

        ; Unlock to apply all changes at once (no flicker!)
        DllCall("LockWindowUpdate", "UInt", 0)
    }

    ; Ensure window update lock is released (safety unlock)
    DllCall("LockWindowUpdate", "UInt", 0)

    ; Stop continuous window update timer
    SetTimer UpdateActualWindow, 0

    previewGui.Destroy()

    ; Final window position sync (only if needed to prevent flash)
    if (IsSet(newW) && IsSet(newH))
    {
        ; Check if window is already at target position
        WinGetPos &currentX, &currentY, &currentW, &currentH, "ahk_id " mwin

        ; Only update if not already at target (prevents flash from redundant update)
        if (currentX != newX || currentY != newY || currentW != newW || currentH != newH) {
            isMaximized := WinGetMinMax("ahk_id " mwin)

            if (isMaximized = 1) {
                WinRestore "ahk_id " mwin
                Sleep 10
            }

            ; Final resize (without the hide/show to reduce flash)
            WinMove newX, newY, newW, newH, "ahk_id " mwin
        }
    }
    resizeActive := false
}

*RButton::
{
    if (GetKeyState("LControl", "P") && GetKeyState("LShift", "P"))
        return
    Click "Right"
}
