; State variables for continuous window updating
windowUpdateTimer_Width := 0
targetWindowFrame_Width := {x: 0, y: 0, w: 0, h: 0}  ; Stores desired window position/size
targetWindowID_Width := 0
initialResizeWidth_Width := 0  ; Track original width for auto-update threshold

; State variables for smart updating (change detection)
lastPreviewFrame_Width := {x: 0, y: 0, w: 0, h: 0}   ; Track last preview frame
lastWindowFrame_Width := {x: 0, y: 0, w: 0, h: 0}    ; Track last window frame

; Motion tracking for intelligent window updates
lastFrameChangeTime_Width := 0                        ; Timestamp of last movement

; Timer callback function: Updates the actual window position/size during resize
UpdateActualWindow_Width() {
    global targetWindowFrame_Width, targetWindowID_Width, lastWindowFrame_Width
    global lastFrameChangeTime_Width, MOTION_PAUSE_THRESHOLD
    global initialResizeWidth_Width, MIN_AUTO_UPDATE_WIDTH_RATIO

    if (!targetWindowID_Width || !WinExist("ahk_id " targetWindowID_Width))
        return

    ; WIDTH CHECK: Don't auto-update if window is too narrow (prevents UI freakout)
    if (initialResizeWidth_Width > 0) {
        widthRatio := targetWindowFrame_Width.w / initialResizeWidth_Width

        ; Block auto-update if width is too small
        if (widthRatio < MIN_AUTO_UPDATE_WIDTH_RATIO)
            return  ; Too narrow, skip auto-update (final update on release still happens)
    }

    ; MOTION CHECK: Only update if we've been stationary for >threshold ms
    timeSinceLastChange := A_TickCount - lastFrameChangeTime_Width
    if (timeSinceLastChange < MOTION_PAUSE_THRESHOLD)
        return  ; Still actively moving, skip window update

    ; SMART UPDATE: Only update if frame has actually changed
    if (FramesEqual_Width(targetWindowFrame_Width, lastWindowFrame_Width))
        return  ; No change, skip expensive WinMove operation

    ; Store this frame for next comparison
    lastWindowFrame_Width := {x: targetWindowFrame_Width.x, y: targetWindowFrame_Width.y,
                              w: targetWindowFrame_Width.w, h: targetWindowFrame_Width.h}

    ; Apply the stored frame to the actual window
    WinMove targetWindowFrame_Width.x, targetWindowFrame_Width.y,
            targetWindowFrame_Width.w, targetWindowFrame_Width.h,
            "ahk_id " targetWindowID_Width

    ; Refresh the window (hide/show trick for visual update)
    WinHide "ahk_id " targetWindowID_Width
    WinShow "ahk_id " targetWindowID_Width
}

; Helper function: Check if two frames are equal (for change detection)
FramesEqual_Width(frame1, frame2) {
    return (frame1.x = frame2.x && frame1.y = frame2.y &&
            frame1.w = frame2.w && frame1.h = frame2.h)
}

; Left Ctrl + Right Mouse Button
^RButton::{
    global scalingModeActive, widthScalingEnabled
    
    if (scalingModeActive)
        return
        
    scalingModeActive := true
    
    if (!widthScalingEnabled) {
        scalingModeActive := false
        return
    }
    
    MouseGetPos ,, &mwin
    
    ; Check if it's a valid window for resizing
    if (!IsValidWindowForResize(mwin)) {
        scalingModeActive := false
        return
    }

    MouseGetPos &startX, &startY, &mwin
    GetWindowVisualPos("ahk_id " mwin, &wx, &wy, &ww, &wh)

    monitorIndex := GetWindowMonitor(wx, wy, ww, wh)
    VirtualMonitorGet(monitorIndex, &monLeft, &monTop, &monRight, &monBottom)
    VirtualMonitorGetWorkArea(monitorIndex, &workLeft, &workTop, &workRight, &workBottom)

    initialW := ww
    initialX := wx
    rightEdgePos := wx + ww  ; Store original right edge position

    ; Store initial width for auto-update threshold check
    global initialResizeWidth_Width
    initialResizeWidth_Width := initialW

    snapEdgeThreshold := 50  ; Pixels from edge to trigger snap
    
    ; Calculate the 1/8 threshold for edge detection
    edgeThreshold := initialW / 8
    
    ; Determine if mouse is near the edges - this mode will be maintained throughout the drag
    isNearLeftEdge := (startX - wx) <= edgeThreshold
    isNearRightEdge := (wx + ww - startX) <= edgeThreshold

    maxWidth := workRight - workLeft

    relativeX := (startX - wx) / initialW

    ; Create preview GUI for main window
    previewGui := Gui("+ToolWindow -Caption +AlwaysOnTop +E0x20")
    previewGui.BackColor := "22B14C"  ; Same nice green as previous version
    WinSetTransparent 75, previewGui.Hwnd
    previewGui.Show("x" wx " y" wy " w" ww " h" wh " NoActivate")

    ; Initialize continuous window update system
    global targetWindowID_Width, WINDOW_UPDATE_INTERVAL
    targetWindowID_Width := mwin
    SetTimer UpdateActualWindow_Width, WINDOW_UPDATE_INTERVAL

    ; Reset smart update state variables
    global lastPreviewFrame_Width, lastWindowFrame_Width, lastFrameChangeTime_Width, targetWindowFrame_Width
    lastPreviewFrame_Width := {x: wx, y: wy, w: ww, h: wh}
    lastWindowFrame_Width := {x: wx, y: wy, w: ww, h: wh}
    lastFrameChangeTime_Width := A_TickCount
    targetWindowFrame_Width := {x: wx, y: wy, w: ww, h: wh}

    snappedWindows := []
    snappedWindowsEnabled := false
    if ( (isNearLeftEdge || isNearRightEdge) && !snappedWindowsEnabled){
        
        snappedWindowsEnabled := true
        
        snappedWindowsInfo := Map()  ; Store original positions and sizes
        
        ; First gather all window edges
        allWindowEdges := []
        DetectHiddenWindows True

        ; Get ALL windows - don't pass any parameters
        windowList := WinGetList()
        ;ToolTip("Found " . windowList.Length . " total windows")
        ;SetTimer () => ToolTip(), -2000

        validWindowCount := 0
        for hwnd in windowList {
            ; Skip invalid windows
            if (!IsValidWindowForResize(hwnd))
                continue
                
            ; Skip windows that no longer exist or aren't valid
            if (!WinExist("ahk_id " hwnd) || !IsValidWindowForResize(hwnd))
                continue
                
            ; Skip windows that don't exist anymore
            if (!WinExist("ahk_id " hwnd))
                continue
                
            ; Use try/catch to handle any errors
            try {
                if (!GetWindowVisualPos("ahk_id " hwnd, &x, &y, &w, &h))
                    continue

                ; Skip windows with invalid positions
                if (x == "" || y == "" || w == "" || h == "")
                    continue
                    
                ; Add edges to our list with window titles for debugging
                try {
                    title := WinGetTitle("ahk_id " hwnd)
                } catch {
                    title := "Unknown"
                }
                
                allWindowEdges.Push({hwnd: hwnd, edge: "left", pos: x, title: title})
                allWindowEdges.Push({hwnd: hwnd, edge: "right", pos: x + w, title: title})
                allWindowEdges.Push({hwnd: hwnd, edge: "top", pos: y, title: title})
                allWindowEdges.Push({hwnd: hwnd, edge: "bottom", pos: y + h, title: title})
                
                validWindowCount++
            } catch {
                ; Skip this window
                continue
            }
        }
        DetectHiddenWindows False

        ; ToolTip("Found " . validWindowCount . " valid windows with " . allWindowEdges.Length . " edges")
        ; SetTimer () => ToolTip(), -2000
        
        ; Determine which border we're operating on (only left or right)
        activeBorder := isNearLeftEdge ? "left" : "right"
        
        ; Find windows snapped to the active border
        snappedWindows := FindWindowsSnappedToBorder(activeBorder, mwin, wx, wy, ww, wh, allWindowEdges)
        
        ; Store original window positions and sizes
        for winInfo in snappedWindows {
            hwnd := winInfo.hwnd
            GetWindowVisualPos("ahk_id " hwnd, &swx, &swy, &sww, &swh)
            snappedWindowsInfo[hwnd] := {x: swx, y: swy, w: sww, h: swh}
        }
        
        ; Create preview GUIs for snapped windows
        previewGuis := Map()
        if (snappedWindows.Length > 0) {
            for snappedWindow in snappedWindows {
                hwnd := snappedWindow.hwnd
                border := snappedWindow.border
                
                ; Skip windows that no longer exist or aren't valid
                if (!WinExist("ahk_id " hwnd) || !IsValidWindowForResize(hwnd))
                    continue
                
                ; Get original position and size
                swInfo := snappedWindowsInfo[hwnd]
                swx := swInfo.x
                swy := swInfo.y
                sww := swInfo.w
                swh := swInfo.h
                
                ; Create a preview GUI for this snapped window
                snapPreview := Gui("+ToolWindow -Caption +AlwaysOnTop +E0x20")
                snapPreview.BackColor := "c74e83"
                WinSetTransparent 75, snapPreview.Hwnd
                ; snapPreview.Show("x" swx " y" swy " w" sww " h" swh " NoActivate")
                
                ; Store the preview GUI
                previewGuis[hwnd] := {
                    gui: snapPreview,
                    border: border,
                    originalX: swx,
                    originalY: swy,
                    originalW: sww,
                    originalH: swh,
                    isVisible: false  ; Track visibility state
                }
            }
        }
    }
    
    While true
    {
        if !GetKeyState("RButton", "P") || !GetKeyState("LControl", "P")
            break

        MouseGetPos &currentX, &currentY

        deltaX := currentX - startX

        ; Calculate new dimensions based on the edge detection mode
        if (isNearLeftEdge) {
            ; LEFT EDGE ONLY MODE: Right edge stays fixed
            newX := initialX + deltaX

            ; Constrain left edge from moving beyond right edge
            newX := Min(newX, rightEdgePos - Colors.MIN_WIDTH)

            ; Calculate width based on fixed right edge
            newW := rightEdgePos - newX

            ; Check monitor based on NEW window position (not mouse position)
            newMonitorIndex := GetWindowMonitor(newX, wy, newW, wh)
            if (newMonitorIndex != monitorIndex) {
                monitorIndex := newMonitorIndex
                VirtualMonitorGet(monitorIndex, &monLeft, &monTop, &monRight, &monBottom)
                VirtualMonitorGetWorkArea(monitorIndex, &workLeft, &workTop, &workRight, &workBottom)

                maxWidth := workRight - workLeft
            }

            ; Constrain left edge from moving beyond screen left
            newX := Max(newX, workLeft)

            ; Recalculate width after constraint
            newW := rightEdgePos - newX

            ; Calculate main right edge position for snapped windows
            mainRightEdge := newX + newW
        }
        else if (isNearRightEdge) {
            ; RIGHT EDGE ONLY MODE: Left edge stays fixed
            newX := initialX  ; Keep left position fixed

            ; Calculate width based on mouse position
            newW := initialW + deltaX

            ; Ensure minimum width
            newW := Max(newW, Colors.MIN_WIDTH)

            ; Check monitor based on NEW window position (not mouse position)
            newMonitorIndex := GetWindowMonitor(newX, wy, newW, wh)
            if (newMonitorIndex != monitorIndex) {
                monitorIndex := newMonitorIndex
                VirtualMonitorGet(monitorIndex, &monLeft, &monTop, &monRight, &monBottom)
                VirtualMonitorGetWorkArea(monitorIndex, &workLeft, &workTop, &workRight, &workBottom)

                maxWidth := workRight - workLeft
            }

            ; Constrain width so right edge doesn't exceed screen right
            newW := Min(newW, workRight - initialX)

            ; Calculate main right edge position for snapped windows
            mainRightEdge := newX + newW
        }
        else {
            ; PROPORTIONAL MODE: Both edges can move
            ; Dynamic sensitivity based on target width
            if (deltaX < 0) {
                ; For reduction (moving mouse left)
                scaleFactor := 1 + (deltaX * 0.003)
            } else {
                ; For expansion (moving mouse right)
                scaleFactor := 1 + (deltaX * 0.003)
            }
            minScaleFactor := Colors.MIN_WIDTH / initialW
            scaleFactor := Max(minScaleFactor, scaleFactor)

            newW := Round(initialW * scaleFactor)
            newW := Max(Colors.MIN_WIDTH, newW)

            ; Apply proportional positioning
            newX := Round(initialX - (newW - initialW) * (1 - relativeX))

            ; Check monitor based on NEW window position (not mouse position)
            newMonitorIndex := GetWindowMonitor(newX, wy, newW, wh)
            if (newMonitorIndex != monitorIndex) {
                monitorIndex := newMonitorIndex
                VirtualMonitorGet(monitorIndex, &monLeft, &monTop, &monRight, &monBottom)
                VirtualMonitorGetWorkArea(monitorIndex, &workLeft, &workTop, &workRight, &workBottom)

                maxWidth := workRight - workLeft
            }

            ; Check if mouse is near screen edge for snapping
            if (currentX >= workRight - snapEdgeThreshold) {
                ; Snap to max width
                newW := maxWidth
                newX := workLeft
            } else {
                ; Constrain to monitor bounds
                newW := Min(newW, maxWidth)
                newX := Max(workLeft, Min(workRight - newW, newX))
            }

            ; Calculate main right edge position for snapped windows
            mainRightEdge := newX + newW
        }

        ; CHANGE DETECTION: Create frame object for comparison
        currentFrame := {x: newX, y: wy, w: newW, h: wh}
        global lastPreviewFrame_Width, lastFrameChangeTime_Width, targetWindowFrame_Width

        ; Check if frame has changed (for motion tracking)
        frameChanged := !FramesEqual_Width(currentFrame, lastPreviewFrame_Width)

        if (frameChanged) {
            lastPreviewFrame_Width := currentFrame
            lastFrameChangeTime_Width := A_TickCount  ; Reset motion timer
            targetWindowFrame_Width := currentFrame   ; Update target for window
            previewGui.Show("NoActivate")  ; Show preview when moving
        } else {
            ; Check if we've been stationary long enough to hide preview
            global MOTION_PAUSE_THRESHOLD, MIN_AUTO_UPDATE_WIDTH_RATIO
            global initialResizeWidth_Width
            timeSinceLastChange := A_TickCount - lastFrameChangeTime_Width

            if (timeSinceLastChange >= MOTION_PAUSE_THRESHOLD) {
                widthRatio := newW / initialResizeWidth_Width

                if (widthRatio >= MIN_AUTO_UPDATE_WIDTH_RATIO) {
                    previewGui.Hide()  ; Hide when large enough and stationary
                }
                ; Keep visible if too small (warning indicator)
            }
        }

        ; ALWAYS update preview position/color (even when hidden, so it's ready when shown)
        ; Lock main preview to prevent flicker
        DllCall("LockWindowUpdate", "UInt", previewGui.Hwnd)

        ; Pass maxWidth + 1 to color calc for better gradient (prevents purple at max width)
        newColor := CalculateColorWidth(newW, initialW, maxWidth + 1, 1)
        previewGui.BackColor := newColor

        ; Update main preview
        WinMove newX, wy, newW, wh, previewGui.Hwnd
        WinSetRegion "0-0 w" newW " h" wh, previewGui.Hwnd

        ; Unlock main preview
        DllCall("LockWindowUpdate", "UInt", 0)
        
        ; Update previews for snapped windows
        if (snappedWindows.Length > 0) {
            if ( GetKeyState("LShift","P") ) {
                ; Show all hidden preview GUIs
                for hwnd, guiInfo in previewGuis {
                    if (!guiInfo.isVisible) {
                        guiInfo.gui.Show("x" guiInfo.originalX " y" guiInfo.originalY 
                                    " w" guiInfo.originalW " h" guiInfo.originalH " NoActivate")
                        guiInfo.isVisible := true
                    }
                }
                for snappedWindow in snappedWindows {
                    hwnd := snappedWindow.hwnd
                    border := snappedWindow.border
                    
                    if (!previewGuis.Has(hwnd))
                        continue
                        
                    snapPreview := previewGuis[hwnd]
                    
                    ; Original values
                    swx := snapPreview.originalX
                    swy := snapPreview.originalY
                    sww := snapPreview.originalW
                    swh := snapPreview.originalH
                    
                    ; Calculate new positions/sizes based on relationship
                    ; Lock this snapped window preview to prevent flicker
                    DllCall("LockWindowUpdate", "UInt", snapPreview.gui.Hwnd)

                    if (isNearLeftEdge) {
                        if (border == "right") {
                            ; Window with RIGHT edge touching our LEFT edge
                            ; Resize this window's width as our left edge moves
                            newSnapW := newX - swx
                            newSnapW := Max(Colors.MIN_WIDTH, newSnapW)

                            ; Update preview
                            newColor := CalculateColorWidth(newSnapW, sww, maxWidth + 1, 2)
                            snapPreview.gui.BackColor := newColor
                            WinMove swx, swy, newSnapW, swh, snapPreview.gui.Hwnd
                            WinSetRegion "0-0 w" newSnapW " h" swh, snapPreview.gui.Hwnd
                        }
                        else if (border == "left") {
                            ; Window with LEFT edge touching our LEFT edge
                            ; Move this window with our left edge
                            WinMove newX, swy, sww, swh, snapPreview.gui.Hwnd
                            WinSetRegion "0-0 w" sww " h" swh, snapPreview.gui.Hwnd
                        }
                    }
                    else if (isNearRightEdge) {
                        if (border == "left") {
                            ; Window with LEFT edge touching our RIGHT edge
                            ; Move and resize this window as our right edge moves
                            newSnapX := mainRightEdge
                            newSnapW := (swx + sww) - mainRightEdge
                            newSnapW := Max(Colors.MIN_WIDTH, newSnapW)

                            ; Update preview
                            newColor := CalculateColorWidth(newSnapW, sww, maxWidth + 1, 2)
                            snapPreview.gui.BackColor := newColor
                            WinMove newSnapX, swy, newSnapW, swh, snapPreview.gui.Hwnd
                            WinSetRegion "0-0 w" newSnapW " h" swh, snapPreview.gui.Hwnd
                        }
                        else if (border == "right") {
                            ; Window with RIGHT edge touching our RIGHT edge
                            ; Resize this window to match our right edge
                            newSnapW := mainRightEdge - swx
                            newSnapW := Max(Colors.MIN_WIDTH, newSnapW)

                            ; Update preview
                            WinMove swx, swy, newSnapW, swh, snapPreview.gui.Hwnd
                            WinSetRegion "0-0 w" newSnapW " h" swh, snapPreview.gui.Hwnd
                        }
                    }

                    ; Unlock this snapped window preview
                    DllCall("LockWindowUpdate", "UInt", 0)
                }
            }
            if ( !GetKeyState("LShift","P") ){
                ; Iterate through all preview GUIs and hide each one
                for hwnd, guiInfo in previewGuis {
                    guiInfo.gui.Hide()
                    guiInfo.isVisible := false
                }
            }
        }

    }

    ; Ensure window update lock is released (safety unlock)
    DllCall("LockWindowUpdate", "UInt", 0)

    ; Stop continuous window update timer
    SetTimer UpdateActualWindow_Width, 0

    ; Apply final size and destroy previews
    previewGui.Destroy()

    ; Set the new dimensions to main and snapped windows
    if (IsSet(newW) && IsSet(newX)) {
        ; Check if window is already at target position
        GetWindowVisualPos("ahk_id " mwin, &currentX, &currentY, &currentW, &currentH)

        ; Only update if not already at target (prevents flash from redundant update)
        if (currentX != newX || currentY != wy || currentW != newW || currentH != wh) {
            ; Check if main window is maximized
            isMaximized := WinGetMinMax("ahk_id " mwin)

            if (isMaximized = 1) {
                WinRestore "ahk_id " mwin
                Sleep 10
            }

            ; Final resize using visual coordinates
            VisualToWinMove("ahk_id " mwin, newX, wy, newW, wh)
        }
        
        ; Now apply the changes to snapped windows
        if ( GetKeyState("LShift","P") ){
            if (snappedWindows.Length > 0) {
                for snappedWindow in snappedWindows {
                    hwnd := snappedWindow.hwnd
                    border := snappedWindow.border
                    
                    if (!previewGuis.Has(hwnd))
                        continue
                        
                    snapPreview := previewGuis[hwnd]
                    
                    ; Use the last position we calculated during the preview updates
                    finalX := 0
                    finalY := 0
                    finalW := 0
                    finalH := 0
                    
                    ; Get the final calculated position based on the window relationship
                    if (isNearLeftEdge) {
                        finalY := snapPreview.originalY
                        finalH := snapPreview.originalH
                        
                        if (border == "right") {
                            ; Window with RIGHT edge touching our LEFT edge
                            finalX := snapPreview.originalX
                            finalW := newX - finalX
                            finalW := Max(Colors.MIN_WIDTH, finalW)
                        } 
                        else if (border == "left") {
                            ; Window with LEFT edge touching our LEFT edge
                            finalX := newX
                            finalW := snapPreview.originalW
                        }
                    } 
                    else if (isNearRightEdge) {
                        finalY := snapPreview.originalY
                        finalH := snapPreview.originalH
                        
                        if (border == "left") {
                            ; Window with LEFT edge touching our RIGHT edge
                            finalX := mainRightEdge
                            finalW := (snapPreview.originalX + snapPreview.originalW) - mainRightEdge
                            finalW := Max(Colors.MIN_WIDTH, finalW)
                        } 
                        else if (border == "right") {
                            ; Window with RIGHT edge touching our RIGHT edge
                            finalX := snapPreview.originalX
                            finalW := mainRightEdge - finalX
                            finalW := Max(Colors.MIN_WIDTH, finalW)
                        }
                    }
                    
                    ; Apply the changes to the real window using visual coordinates
                    VisualToWinMove("ahk_id " hwnd, finalX, finalY, finalW, finalH)
                    
                    ; ; Force refresh
                    ; WinHide "ahk_id " hwnd
                    ; WinShow "ahk_id " hwnd
                }
            }
        }
        
        if (snappedWindowsEnabled){
            ; Destroy snapped window previews - do this AFTER moving windows
            for hwnd, snapPreview in previewGuis {
                snapPreview.gui.Destroy()
            }
        }
    }
    
    scalingModeActive := false
}
