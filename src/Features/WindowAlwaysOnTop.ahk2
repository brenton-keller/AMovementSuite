#Requires AutoHotkey v2.0
#SingleInstance Force

; Initialize global variables
global windowsAlwaysOnTop := Map() ; Track which windows are set as always-on-top

; Hotkey: Left Control + Middle Mouse Button - Always On Top
<^MButton::AlwaysOnTop()

; Hotkey: Alt + Middle Mouse Button - Send to Back
!MButton::SendWindowToBack()

; Hotkey: Win + Middle Mouse Button - Send to Back + Minimize
#MButton::SendToBackAndMinimize()

/** AlwaysOnTop
 * Toggles the always-on-top state for the window currently under the mouse cursor.
 * Provides visual feedback and handles Z-order management for window activation.
 * 
 * @global {Boolean} windowAlwaysOnTopEnabled Controls whether the always-on-top functionality is active
 * @global {Object} windowsAlwaysOnTop Tracks windows currently set to always-on-top
 * 
 * @returns {void}
 * 
 * @behavior
 * - Checks if always-on-top functionality is enabled
 * - Validates the window under the mouse cursor
 * - Toggles always-on-top state with visual notification
 * - Manages window Z-order when changing always-on-top state
 * 
 * @example
 * ; User can trigger this function to make the window under the mouse always visible
 * AlwaysOnTop()  ; Toggles always-on-top for window under mouse
 * 
 * @notes
 * - Requires valid window handle under mouse cursor
 * - Provides debug messages for invalid windows
 * - Shows toggle notification for user feedback
 */
AlwaysOnTop() {
    global windowAlwaysOnTopEnabled

    ; Check if functionality is enabled
    if (!windowAlwaysOnTopEnabled)
        return
        
    MouseGetPos , , &mwin
    
    ; Check if we have a valid window
    if (!mwin) {
        ShowDebugMessage("No window detected under cursor")
        return
    }
    
    ; Check if it's a valid window for always-on-top
    if (!IsValidWindowForTopMost(mwin)) {
        ShowDebugMessage("This window cannot be set as always-on-top")
        return
    }
    
    ; Get the currently active window (which may be different from the window under mouse)
    activeWin := WinGetID("A")
    
    ExStyle := WinGetExStyle("ahk_id " mwin)
    winTitle := WinGetTitle("ahk_id " mwin)
    
    ; Toggle the always-on-top state
    if (ExStyle & 0x8) { ; 0x8 is WS_EX_TOPMOST
        ; Remove always-on-top
        WinSetAlwaysOnTop 0, "ahk_id " mwin
        windowsAlwaysOnTop.Delete(mwin)
        ShowToggleNotification("Always on Top: OFF", winTitle)
        
        ; Fix Z-order: If we're turning off always-on-top for a non-active window,
        ; make sure the active window comes to the front
        if (mwin != activeWin && WinExist("ahk_id " activeWin)) {
            if (WinGetMinMax("ahk_id " activeWin) != -1) { ; Not minimized
                ; Fix Z-order using direct Windows API calls
                ; First make active window topmost, then remove that flag
                DllCall("SetWindowPos", "Ptr", activeWin, "Ptr", -1, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x213)
                DllCall("SetWindowPos", "Ptr", activeWin, "Ptr", -2, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x213)
                WinActivate "ahk_id " activeWin
            }
        }
    } else {
        ; Set always-on-top
        WinSetAlwaysOnTop 1, "ahk_id " mwin
        windowsAlwaysOnTop[mwin] := true
        ShowToggleNotification("Always on Top: ON", winTitle)
    }
}

/** SendWindowToBack
 * Sends the window under the mouse cursor to the back of the Z-order stack.
 * Provides visual feedback when the window is sent to back.
 */
SendWindowToBack() {
    MouseGetPos , , &mwin
    
    ; Check if we have a valid window
    if (!mwin) {
        ShowDebugMessage("No window detected under cursor")
        return
    }
    
    ; Check if it's a valid window for manipulation
    if (!IsValidWindowForManipulation(mwin)) {
        ShowDebugMessage("This window cannot be sent to back")
        return
    }
    
    winTitle := WinGetTitle("ahk_id " mwin)
    
    ; Check if this is the active window
    isActiveWindow := (mwin = WinGetID("A"))
    
    ; Send window to back using Windows API
    ; HWND_BOTTOM = 1
    DllCall("SetWindowPos", "Ptr", mwin, "Ptr", 1, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x213)
    
    ; If we sent the active window to back, activate the next window
    if (isActiveWindow) {
        SendInput "!{Esc}"  ; Use Alt+Esc to activate the next window in Z-order
    }
    
    ShowToggleNotification("Window sent to back", winTitle)
}

/** MinimizeWindow
 * Minimizes the window under the mouse cursor.
 * Provides visual feedback when the window is minimized.
 */
MinimizeWindow() {
    MouseGetPos , , &mwin

    ; Check if we have a valid window
    if (!mwin) {
        ShowDebugMessage("No window detected under cursor")
        return
    }

    ; Check if it's a valid window for manipulation
    if (!IsValidWindowForManipulation(mwin)) {
        ShowDebugMessage("This window cannot be minimized")
        return
    }

    winTitle := WinGetTitle("ahk_id " mwin)

    ; Minimize the window
    WinMinimize "ahk_id " mwin

    ShowToggleNotification("Window minimized", winTitle)
}

/** SendToBackAndMinimize
 * Sends the window under the mouse cursor to the back of the Z-order stack, then minimizes it.
 * Provides visual feedback when the action is performed.
 */
SendToBackAndMinimize() {
    MouseGetPos , , &mwin

    ; Check if we have a valid window
    if (!mwin) {
        ShowDebugMessage("No window detected under cursor")
        return
    }

    ; Check if it's a valid window for manipulation
    if (!IsValidWindowForManipulation(mwin)) {
        ShowDebugMessage("This window cannot be sent to back and minimized")
        return
    }

    winTitle := WinGetTitle("ahk_id " mwin)

    ; Check if this is the active window
    isActiveWindow := (mwin = WinGetID("A"))

    ; Send window to back using Windows API
    ; HWND_BOTTOM = 1
    DllCall("SetWindowPos", "Ptr", mwin, "Ptr", 1, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x213)

    ; If we sent the active window to back, activate the next window
    if (isActiveWindow) {
        SendInput "!{Esc}"  ; Use Alt+Esc to activate the next window in Z-order
    }

    ; Brief delay to allow Z-order change to complete
    Sleep 100

    ; Minimize the window
    WinMinimize "ahk_id " mwin

    ShowToggleNotification("Window sent to back and minimized", winTitle)
}

; Show a brief notification about the toggle action
ShowToggleNotification(message, winTitle := "") {
    winInfo := winTitle ? " (" winTitle ")" : ""
    ToolTip message winInfo
    SetTimer () => ToolTip(), -2000
}

; Show debug messages
ShowDebugMessage(message) {
    ToolTip message
    SetTimer () => ToolTip(), -2000
}

; Check if it's a valid window for setting always-on-top
IsValidWindowForTopMost(hwnd) {
    if (!hwnd)
        return false
        
    ; Don't allow setting always-on-top for certain system windows
    windowClass := WinGetClass("ahk_id " hwnd)
    
    ; List of classes that shouldn't be set to always-on-top
    excludedClasses := ["Progman", "WorkerW", "Shell_TrayWnd", "Windows.UI.Core.CoreWindow", 
                       "ApplicationFrameWindow", "SysListView32", "NotifyIconOverflowWindow"]
    
    for class in excludedClasses {
        if (windowClass == class)
            return false
    }
    
    ; Check if the window is a system dialog
    if (WinGetStyle("ahk_id " hwnd) & 0x08000000) { ; WS_POPUP
        title := WinGetTitle("ahk_id " hwnd)
        if (title ~= "i)^(Error|Warning|Info|Confirm|Prompt)")
            return false
    }
    
    ; Check if window is minimized
    if (WinGetMinMax("ahk_id " hwnd) == -1)
        return false
        
    return true
}

; Check if it's a valid window for general manipulation (send to back, minimize)
IsValidWindowForManipulation(hwnd) {
    if (!hwnd)
        return false
        
    ; Don't allow manipulating certain system windows
    windowClass := WinGetClass("ahk_id " hwnd)
    
    ; List of classes that shouldn't be manipulated
    excludedClasses := ["Progman", "WorkerW", "Shell_TrayWnd", "Windows.UI.Core.CoreWindow", 
                       "SysListView32", "NotifyIconOverflowWindow"]
    
    for class in excludedClasses {
        if (windowClass == class)
            return false
    }
    
    ; Check if the window is a system dialog
    if (WinGetStyle("ahk_id " hwnd) & 0x08000000) { ; WS_POPUP
        title := WinGetTitle("ahk_id " hwnd)
        if (title ~= "i)^(Error|Warning|Info|Confirm|Prompt)")
            return false
    }
    
    return true
}
