; State variables for continuous window updating
windowUpdateTimer_Height := 0
targetWindowFrame_Height := {x: 0, y: 0, w: 0, h: 0}  ; Stores desired window position/size
targetWindowID_Height := 0
initialResizeHeight_Height := 0  ; Track original height for auto-update threshold

; State variables for smart updating (change detection)
lastPreviewFrame_Height := {x: 0, y: 0, w: 0, h: 0}   ; Track last preview frame
lastWindowFrame_Height := {x: 0, y: 0, w: 0, h: 0}    ; Track last window frame

; Motion tracking for intelligent window updates
lastFrameChangeTime_Height := 0                        ; Timestamp of last movement

; Timer callback function: Updates the actual window position/size during resize
UpdateActualWindow_Height() {
    global targetWindowFrame_Height, targetWindowID_Height, lastWindowFrame_Height
    global lastFrameChangeTime_Height, MOTION_PAUSE_THRESHOLD
    global initialResizeHeight_Height, MIN_AUTO_UPDATE_HEIGHT_RATIO

    if (!targetWindowID_Height || !WinExist("ahk_id " targetWindowID_Height))
        return

    ; HEIGHT CHECK: Don't auto-update if window is too short (prevents UI freakout)
    if (initialResizeHeight_Height > 0) {
        heightRatio := targetWindowFrame_Height.h / initialResizeHeight_Height

        ; Block auto-update if height is too small
        if (heightRatio < MIN_AUTO_UPDATE_HEIGHT_RATIO)
            return  ; Too short, skip auto-update (final update on release still happens)
    }

    ; MOTION CHECK: Only update if we've been stationary for >threshold ms
    timeSinceLastChange := A_TickCount - lastFrameChangeTime_Height
    if (timeSinceLastChange < MOTION_PAUSE_THRESHOLD)
        return  ; Still actively moving, skip window update

    ; SMART UPDATE: Only update if frame has actually changed
    if (FramesEqual_Height(targetWindowFrame_Height, lastWindowFrame_Height))
        return  ; No change, skip expensive WinMove operation

    ; Store this frame for next comparison
    lastWindowFrame_Height := {x: targetWindowFrame_Height.x, y: targetWindowFrame_Height.y,
                               w: targetWindowFrame_Height.w, h: targetWindowFrame_Height.h}

    ; Apply the stored frame to the actual window
    WinMove targetWindowFrame_Height.x, targetWindowFrame_Height.y,
            targetWindowFrame_Height.w, targetWindowFrame_Height.h,
            "ahk_id " targetWindowID_Height

    ; Refresh the window (hide/show trick for visual update)
    WinHide "ahk_id " targetWindowID_Height
    WinShow "ahk_id " targetWindowID_Height
}

; Helper function: Check if two frames are equal (for change detection)
FramesEqual_Height(frame1, frame2) {
    return (frame1.x = frame2.x && frame1.y = frame2.y &&
            frame1.w = frame2.w && frame1.h = frame2.h)
}

; Left Shift + Right Mouse Button
+RButton::{
    global scalingModeActive, heightScalingEnabled

    ; If a scaling operation is already active, exit
    if (scalingModeActive)
        return

    ; Set flag to lock scaling mode
    scalingModeActive := true

    ; Check if functionality is enabled
    if (!heightScalingEnabled) {
        scalingModeActive := false
        return
    }

    MouseGetPos ,, &mwin
    
    ; Check if it's a valid window for resizing
    if (!IsValidWindowForResize(mwin)) {
        scalingModeActive := false
        return
    }

    MouseGetPos &startX, &startY, &mwin
    WinGetPos &wx, &wy, &ww, &wh, "ahk_id " mwin

    ; Get the monitor containing the window
    monitorIndex := GetWindowMonitor(wx, wy, ww, wh)
    MonitorGet(monitorIndex, &monLeft, &monTop, &monRight, &monBottom)
    MonitorGetWorkArea(monitorIndex, &workLeft, &workTop, &workRight, &workBottom)

    ; Initial values
    initialH := wh
    initialY := wy
    bottomEdgePos := wy + wh  ; Store original bottom edge position

    ; Store initial height for auto-update threshold check
    global initialResizeHeight_Height
    initialResizeHeight_Height := initialH

    snapEdgeThreshold := 50  ; Pixels from edge to trigger snap

    ; Calculate the 1/8 threshold for edge detection
    edgeThreshold := initialH / 8
    
    ; Determine if mouse is near the edges - this mode will be maintained throughout the drag
    isNearTopEdge := (startY - wy) <= edgeThreshold
    isNearBottomEdge := (wy + wh - startY) <= edgeThreshold

    ; Calculate maximum height and add safety check
    maxHeight := workBottom - workTop
    if (maxHeight <= initialH) {
        maxHeight := initialH + 1  ; Add 1 pixel buffer to prevent division by zero
    }

    relativeY := (startY - wy) / initialH

    ; Create preview GUI
    previewGui := Gui("+ToolWindow -Caption +AlwaysOnTop +E0x20")
    previewGui.BackColor := Format("{:06X}", Colors.BASELINE.R << 16 | Colors.BASELINE.G << 8 | Colors.BASELINE.B)
    WinSetTransparent 75, previewGui.Hwnd
    previewGui.Show("x" wx " y" wy " w" ww " h" wh " NoActivate")

    ; Initialize continuous window update system
    global targetWindowID_Height, WINDOW_UPDATE_INTERVAL
    targetWindowID_Height := mwin
    SetTimer UpdateActualWindow_Height, WINDOW_UPDATE_INTERVAL

    ; Reset smart update state variables
    global lastPreviewFrame_Height, lastWindowFrame_Height, lastFrameChangeTime_Height, targetWindowFrame_Height
    lastPreviewFrame_Height := {x: wx, y: wy, w: ww, h: wh}
    lastWindowFrame_Height := {x: wx, y: wy, w: ww, h: wh}
    lastFrameChangeTime_Height := A_TickCount
    targetWindowFrame_Height := {x: wx, y: wy, w: ww, h: wh}

    While true
    {
        if !GetKeyState("RButton", "P") || !GetKeyState("LShift", "P")
            break

        MouseGetPos &currentX, &currentY
        
        ; Check for monitor changes during drag
        newMonitorIndex := MonitorFromPoint(currentX, currentY)
        if (newMonitorIndex != monitorIndex) {
            monitorIndex := newMonitorIndex
            MonitorGet(monitorIndex, &monLeft, &monTop, &monRight, &monBottom)
            MonitorGetWorkArea(monitorIndex, &workLeft, &workTop, &workRight, &workBottom)
            
            maxHeight := workBottom - workTop
            if (maxHeight <= initialH) {
                maxHeight := initialH + 1
            }
        }

        deltaX := currentX - startX
        
        ; Always use horizontal movement to control size consistently
        ; Positive deltaX = increase height, negative = decrease height
        
        if (isNearTopEdge) {
            ; TOP EDGE ONLY MODE: Bottom edge stays fixed
            ; Moving right increases height (moves top edge up)
            ; Moving left decreases height (moves top edge down)
            scaleFactor := 1 + (deltaX * 0.003/2)
            
            if (deltaX > 0) {
                ; Increasing height (moving top edge up)
                newH := Min(initialH * scaleFactor, bottomEdgePos - workTop)
            } else {
                ; Decreasing height (moving top edge down)
                newH := Max(initialH * scaleFactor, Colors.MIN_HEIGHT)
            }
            
            ; Calculate new top position based on fixed bottom
            newY := bottomEdgePos - newH
            
            ; Ensure top doesn't go above screen
            newY := Max(newY, workTop)
            
            ; Recalculate height based on new top position
            newH := bottomEdgePos - newY
        }
        else if (isNearBottomEdge) {
            ; BOTTOM EDGE ONLY MODE: Top edge stays fixed
            ; Moving right increases height (moves bottom edge down)
            ; Moving left decreases height (moves bottom edge up)
            
            if (deltaX > 0) {
                ; Increasing height
                scaleFactor := 1 + (deltaX * 0.003/2)
            } else {
                ; Decreasing height
                scaleFactor := 1 + (deltaX * 0.003/2)
            }
            
            newY := initialY  ; Keep top position fixed
            newH := initialH * scaleFactor
            
            ; Constrain height so bottom edge doesn't exceed screen bottom
            newH := Min(newH, workBottom - initialY)
            
            ; Ensure minimum height
            newH := Max(newH, Colors.MIN_HEIGHT)
        }
        else {
            ; PROPORTIONAL MODE: Both edges can move
            ; Check if mouse is near screen edge for snapping
            if (currentX >= workRight - snapEdgeThreshold) {
                ; Snap to max height
                newH := maxHeight
                newY := workTop
            }
            else {
                ; Dynamic sensitivity based on target height
                if (deltaX < 0) {
                    ; For reduction (moving mouse left)
                    scaleFactor := 1 + (deltaX * 0.003)
                } else {
                    ; For expansion (moving mouse right)
                    scaleFactor := 1 + (deltaX * 0.003)
                }
                scaleFactor := Max(0.1, scaleFactor)  ; Allow smaller minimum scale
                
                newH := Round(initialH * scaleFactor)
                newH := Max(Colors.MIN_HEIGHT, Min(newH, maxHeight))
                
                ; Calculate vertical position for proportional resize
                ; newY := Round(startY - (newH * relativeY))
                ; newY := Max(workTop, Min(workBottom - newH, newY))
                newY := Round(initialY - (newH - initialH) * (1 - relativeY))
                newY := Max(workTop, Min(workBottom - newH, newY))
            }
        }

        ; CHANGE DETECTION: Create frame object for comparison
        currentFrame := {x: wx, y: newY, w: ww, h: newH}
        global lastPreviewFrame_Height, lastFrameChangeTime_Height, targetWindowFrame_Height

        ; Check if frame has changed (for motion tracking)
        frameChanged := !FramesEqual_Height(currentFrame, lastPreviewFrame_Height)

        if (frameChanged) {
            lastPreviewFrame_Height := currentFrame
            lastFrameChangeTime_Height := A_TickCount  ; Reset motion timer
            targetWindowFrame_Height := currentFrame   ; Update target for window
            previewGui.Show("NoActivate")  ; Show preview when moving
        } else {
            ; Check if we've been stationary long enough to hide preview
            global MOTION_PAUSE_THRESHOLD, MIN_AUTO_UPDATE_HEIGHT_RATIO
            global initialResizeHeight_Height
            timeSinceLastChange := A_TickCount - lastFrameChangeTime_Height

            if (timeSinceLastChange >= MOTION_PAUSE_THRESHOLD) {
                heightRatio := newH / initialResizeHeight_Height

                if (heightRatio >= MIN_AUTO_UPDATE_HEIGHT_RATIO) {
                    previewGui.Hide()  ; Hide when large enough and stationary
                }
                ; Keep visible if too small (warning indicator)
            }
        }

        ; ALWAYS update preview position/color (even when hidden, so it's ready when shown)
        ; Update preview color based on new height
        newColor := CalculateColorHeight(newH, initialH, maxHeight)
        previewGui.BackColor := newColor

        ; Update preview
        WinMove wx, newY, ww, newH, previewGui.Hwnd
        WinSetRegion "0-0 w" ww " h" newH, previewGui.Hwnd
    }

    ; Stop continuous window update timer
    SetTimer UpdateActualWindow_Height, 0

    ; Apply final size and destroy preview
    previewGui.Destroy()

    ; Final window position sync (only if needed to prevent flash)
    if (IsSet(newH) && IsSet(newY))
    {
        ; Check if window is already at target position
        WinGetPos &currentX, &currentY, &currentW, &currentH, "ahk_id " mwin

        ; Only update if not already at target (prevents flash from redundant update)
        if (currentX != wx || currentY != newY || currentW != ww || currentH != newH) {
            ; Check if window is maximized
            isMaximized := WinGetMinMax("ahk_id " mwin)

            if (isMaximized = 1) {
                WinRestore "ahk_id " mwin
                Sleep 10
            }

            ; Final resize (without the hide/show to reduce flash)
            WinMove wx, newY, ww, newH, "ahk_id " mwin
        }
    }

    scalingModeActive := false
}
