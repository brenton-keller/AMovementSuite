; Left Shift + Right Mouse Button
+RButton::{
    global scalingModeActive, heightScalingEnabled

    ; If a scaling operation is already active, exit
    if (scalingModeActive)
        return

    ; Set flag to lock scaling mode
    scalingModeActive := true

    ; Check if functionality is enabled
    if (!heightScalingEnabled) {
        scalingModeActive := false
        return
    }

    MouseGetPos ,, &mwin
    
    ; Check if it's a valid window for resizing
    if (!IsValidWindowForResize(mwin)) {
        scalingModeActive := false
        return
    }

    MouseGetPos &startX, &startY, &mwin
    WinGetPos &wx, &wy, &ww, &wh, "ahk_id " mwin

    ; Get the monitor containing the window
    monitorIndex := GetWindowMonitor(wx, wy, ww, wh)
    MonitorGet(monitorIndex, &monLeft, &monTop, &monRight, &monBottom)
    MonitorGetWorkArea(monitorIndex, &workLeft, &workTop, &workRight, &workBottom)

    ; Initial values
    initialH := wh
    initialY := wy
    bottomEdgePos := wy + wh  ; Store original bottom edge position
    
    snapEdgeThreshold := 50  ; Pixels from edge to trigger snap
    
    ; Calculate the 1/8 threshold for edge detection
    edgeThreshold := initialH / 8
    
    ; Determine if mouse is near the edges - this mode will be maintained throughout the drag
    isNearTopEdge := (startY - wy) <= edgeThreshold
    isNearBottomEdge := (wy + wh - startY) <= edgeThreshold

    ; Calculate maximum height and add safety check
    maxHeight := workBottom - workTop
    if (maxHeight <= initialH) {
        maxHeight := initialH + 1  ; Add 1 pixel buffer to prevent division by zero
    }

    relativeY := (startY - wy) / initialH

    ; Create preview GUI
    previewGui := Gui("+ToolWindow -Caption +AlwaysOnTop +E0x20")
    previewGui.BackColor := Format("{:06X}", Colors.BASELINE.R << 16 | Colors.BASELINE.G << 8 | Colors.BASELINE.B)
    WinSetTransparent 75, previewGui.Hwnd
    previewGui.Show("x" wx " y" wy " w" ww " h" wh " NoActivate")

    While true
    {
        if !GetKeyState("RButton", "P") || !GetKeyState("LShift", "P")
            break

        MouseGetPos &currentX, &currentY
        
        ; Check for monitor changes during drag
        newMonitorIndex := MonitorFromPoint(currentX, currentY)
        if (newMonitorIndex != monitorIndex) {
            monitorIndex := newMonitorIndex
            MonitorGet(monitorIndex, &monLeft, &monTop, &monRight, &monBottom)
            MonitorGetWorkArea(monitorIndex, &workLeft, &workTop, &workRight, &workBottom)
            
            maxHeight := workBottom - workTop
            if (maxHeight <= initialH) {
                maxHeight := initialH + 1
            }
        }

        deltaX := currentX - startX
        
        ; Always use horizontal movement to control size consistently
        ; Positive deltaX = increase height, negative = decrease height
        
        if (isNearTopEdge) {
            ; TOP EDGE ONLY MODE: Bottom edge stays fixed
            ; Moving right increases height (moves top edge up)
            ; Moving left decreases height (moves top edge down)
            scaleFactor := 1 + (deltaX * 0.003/2)
            
            if (deltaX > 0) {
                ; Increasing height (moving top edge up)
                newH := Min(initialH * scaleFactor, bottomEdgePos - workTop)
            } else {
                ; Decreasing height (moving top edge down)
                newH := Max(initialH * scaleFactor, Colors.MIN_HEIGHT)
            }
            
            ; Calculate new top position based on fixed bottom
            newY := bottomEdgePos - newH
            
            ; Ensure top doesn't go above screen
            newY := Max(newY, workTop)
            
            ; Recalculate height based on new top position
            newH := bottomEdgePos - newY
        }
        else if (isNearBottomEdge) {
            ; BOTTOM EDGE ONLY MODE: Top edge stays fixed
            ; Moving right increases height (moves bottom edge down)
            ; Moving left decreases height (moves bottom edge up)
            
            if (deltaX > 0) {
                ; Increasing height
                scaleFactor := 1 + (deltaX * 0.003/2)
            } else {
                ; Decreasing height
                scaleFactor := 1 + (deltaX * 0.003/2)
            }
            
            newY := initialY  ; Keep top position fixed
            newH := initialH * scaleFactor
            
            ; Constrain height so bottom edge doesn't exceed screen bottom
            newH := Min(newH, workBottom - initialY)
            
            ; Ensure minimum height
            newH := Max(newH, Colors.MIN_HEIGHT)
        }
        else {
            ; PROPORTIONAL MODE: Both edges can move
            ; Check if mouse is near screen edge for snapping
            if (currentX >= workRight - snapEdgeThreshold) {
                ; Snap to max height
                newH := maxHeight
                newY := workTop
            }
            else {
                ; Dynamic sensitivity based on target height
                if (deltaX < 0) {
                    ; For reduction (moving mouse left)
                    scaleFactor := 1 + (deltaX * 0.003)
                } else {
                    ; For expansion (moving mouse right)
                    scaleFactor := 1 + (deltaX * 0.003)
                }
                scaleFactor := Max(0.1, scaleFactor)  ; Allow smaller minimum scale
                
                newH := Round(initialH * scaleFactor)
                newH := Max(Colors.MIN_HEIGHT, Min(newH, maxHeight))
                
                ; Calculate vertical position for proportional resize
                ; newY := Round(startY - (newH * relativeY))
                ; newY := Max(workTop, Min(workBottom - newH, newY))
                newY := Round(initialY - (newH - initialH) * (1 - relativeY))
                newY := Max(workTop, Min(workBottom - newH, newY))
            }
        }

        ; Update preview color based on new height
        newColor := CalculateColorHeight(newH, initialH, maxHeight)
        previewGui.BackColor := newColor

        ; Update preview
        WinMove wx, newY, ww, newH, previewGui.Hwnd
        WinSetRegion "0-0 w" ww " h" newH, previewGui.Hwnd
    }

    ; Apply final size and destroy preview
    previewGui.Destroy()
    if (IsSet(newH) && IsSet(newY))
    {
        ; Check if window is maximized
        isMaximized := WinGetMinMax("ahk_id " mwin)
        
        if (isMaximized = 1) ; 1 means maximized
        {
            ; Restore the window first
            WinRestore "ahk_id " mwin
            ; Small sleep to ensure the restore completes
            Sleep 10
        }
        
        ; Apply new dimensions
        WinMove wx, newY, ww, newH, "ahk_id " mwin
        
        ; Force a refresh to prevent visual artifacts
        WinHide "ahk_id " mwin
        WinShow "ahk_id " mwin
    }
    
    scalingModeActive := false
}
