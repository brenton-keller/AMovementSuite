
CheckForKeyRelease() {
    global scalingModeActive

    static wasReleased := true
    
    ; If RButton is not pressed, reset the scaling state
    if (!GetKeyState("RButton", "P")) {
        if (scalingModeActive) {
            scalingModeActive := false
            wasReleased := true
            ToolTip  ; Clear any tooltips
        }
    } else if (scalingModeActive && wasReleased) {
        wasReleased := false
    }
}

InitSafetyTimer() {
    ; Set a timer to check for key release in case of errors
    SetTimer(CheckForKeyRelease, 250)
}

InitSafetyTimer()

ShowWindowMoveSettings(*) {
    global enableWindowSnapping, snapDistance
    
    ; Create the settings window
    settingsGui := Gui("+AlwaysOnTop +ToolWindow", "Window Move Settings")
    
    ; Add checkbox for window snapping
    settingsGui.Add("CheckBox", "vWindowSnapping Checked" enableWindowSnapping, "Enable Window Snapping")
    
    ; Add snap distance slider
    settingsGui.Add("Text", "xm y+15", "Snap Distance (pixels):")
    settingsGui.Add("Slider", "vSnapDistance Range1-25 TickInterval5 Tooltip w200", snapDistance)
    
    ; Show current value
    settingsGui.Add("Text", "x+5 w30 vCurrentValue", snapDistance)
    
    ; Add buttons
    settingsGui.Add("Button", "xm y+15 w80 Default", "OK").OnEvent("Click", SaveSettings)
    settingsGui.Add("Button", "x+10 w80", "Cancel").OnEvent("Click", CloseSettings)
    
    ; Event for updating the displayed value
    sliderControl := settingsGui["SnapDistance"]
    sliderControl.OnEvent("Change", UpdateValue)
    
    ; Show the GUI
    settingsGui.Show()
    
    UpdateValue(*) {
        settingsGui["CurrentValue"].Value := sliderControl.Value
    }
    
    SaveSettings(*) {
        Saved := settingsGui.Submit()
        enableWindowSnapping := Saved.WindowSnapping
        snapDistance := Saved.SnapDistance
        settingsGui.Destroy()
    }
    
    CloseSettings(*) {
        settingsGui.Destroy()
    }
}

ShowProgramPathsConfig(*) {
    ; Get current status of all configured programs
    status := ProgramPaths.GetStatus()

    ; Create the settings window
    pathsGui := Gui("+AlwaysOnTop +Resize", "Program Paths Configuration")
    pathsGui.SetFont("s10")

    ; Title text
    pathsGui.Add("Text", "w500", "Detected Program Paths")
    pathsGui.Add("Text", "w500", "✓ = Found  |  ✗ = Not Found")
    pathsGui.Add("Text", "w500", "")  ; Spacer

    ; Display each program's status
    yPos := 80
    for name, info in status {
        ; Status indicator
        indicator := info.exists ? "✓" : "✗"
        color := info.exists ? "Green" : "Red"

        ; Program name
        pathsGui.SetFont("Bold")
        pathsGui.Add("Text", "x20 y" yPos " w100", name ":")
        pathsGui.SetFont()

        ; Status
        pathsGui.SetFont("c" color " Bold")
        pathsGui.Add("Text", "x+10 w30", indicator)
        pathsGui.SetFont()

        ; Path
        pathsGui.Add("Edit", "x+10 w400 ReadOnly", info.path)

        yPos += 35
    }

    ; Spacer
    pathsGui.Add("Text", "xm y" yPos " w500", "")
    yPos += 10

    ; Instructions
    pathsGui.SetFont("s9 Italic")
    pathsGui.Add("Text", "xm y" yPos " w500",
        "To customize paths for this machine:")
    pathsGui.Add("Text", "xm y+" yPos " w500",
        "1. Copy: src\lib\Config\UserConfig.template.ahk2")
    pathsGui.Add("Text", "xm y+" yPos " w500",
        "2. To: src\lib\Config\UserConfig.local.ahk2")
    pathsGui.Add("Text", "xm y+" yPos " w500",
        "3. Edit UserConfig.local.ahk2 with your custom paths")
    pathsGui.Add("Text", "xm y+" yPos " w500",
        "4. Reload this script")
    pathsGui.SetFont()

    yPos += 110

    ; Buttons
    pathsGui.Add("Button", "xm y" yPos " w120 Default", "Open Config Folder").OnEvent("Click", OpenConfigFolder)
    pathsGui.Add("Button", "x+10 w120", "Reload Script").OnEvent("Click", ReloadScript)
    pathsGui.Add("Button", "x+10 w120", "Close").OnEvent("Click", (*) => pathsGui.Destroy())

    ; Show the GUI
    pathsGui.Show("w560 h" (yPos + 50))

    OpenConfigFolder(*) {
        Run 'explorer.exe "' A_ScriptDir '\src\lib\Config"'
    }

    ReloadScript(*) {
        Reload
    }
}

GetWindowMonitor(winX, winY, winWidth, winHeight) {
    winCenterX := winX + (winWidth / 2)
    winCenterY := winY + (winHeight / 2)
    
    MonitorCount := MonitorGetCount()
    Loop MonitorCount {
        MonitorGet(A_Index, &MonLeft, &MonTop, &MonRight, &MonBottom)
        if (winCenterX >= MonLeft && winCenterX <= MonRight
            && winCenterY >= MonTop && winCenterY <= MonBottom)
            return A_Index
    }
    return 1
}

IsValidWindowForResize(hwnd) {
    ; Get window class
    windowClass := WinGetClass("ahk_id " hwnd)
    
    ; List of classes to exclude (add more as needed)
    excludedClasses := [
        "#32768",    ; Standard Windows context menus
        "Windows.UI.Core.CoreWindow",  ; Modern context menus
        "ToolbarWindow32"
        "DropDown",
        "Popup",
        "PopupMenu"
    ]
    
    ; ; Check if window is excluded
    for excludedClass in excludedClasses {
        if (windowClass = excludedClass)
            return false
    }
    
    ; Additional checks
    if (!WinGetTitle("ahk_id " hwnd))  ; No title usually means temporary window
        return false
        
    if (WinGetStyle("ahk_id " hwnd) & 0x40000000)  ; Check if it's a child window
        return false
    
    return true
}

GetMonitorAtPos(x, y) {
    MonitorCount := MonitorGetCount()
    Loop MonitorCount {
        MonitorGet(A_Index, &MonLeft, &MonTop, &MonRight, &MonBottom)
        if (x >= MonLeft && x <= MonRight && y >= MonTop && y <= MonBottom)
            return A_Index
    }
    return 1
}

; When script starts, enter "click to analyze" mode
AnalyzeWindow() {
    ; Show instruction message
    MsgBox("Click on a window to analyze whether it's valid for resizing.", "Window Validator")
    
    ; Make sure we start with mouse released
    KeyWait "LButton"
    
    ; Then wait for a click
    KeyWait "LButton", "D"
    Sleep 100  ; Small delay to ensure click registers fully
    
    ; Get the window under the cursor
    MouseGetPos(, , &clickedWin)
    
    ; Get window info
    windowClass := WinGetClass("ahk_id " clickedWin)
    windowTitle := WinGetTitle("ahk_id " clickedWin)
    windowStyle := WinGetStyle("ahk_id " clickedWin)
    
    ; Check validity
    isValid := IsValidWindowForMove(clickedWin)
    
    ; Determine why it might be invalid
    reason := ""
    
    ; Check if window is in excluded classes
    excludedClasses := [
        "#32768",    ; Standard Windows context menus
        "Windows.UI.Core.CoreWindow",  ; Modern context menus
        "ToolbarWindow32",
        "DropDown",
        "Popup",
        "PopupMenu"
    ]
    
    for excludedClass in excludedClasses {
        if (windowClass = excludedClass) {
            reason .= "• Window class is in exclusion list: " excludedClass "`n"
            break
        }
    }
    
    ; Check title
    if (!windowTitle)
        reason .= "• Window has no title`n"
    
    ; Check if child window
    if (windowStyle & 0x40000000)
        reason .= "• Window is a child window (WS_CHILD style detected)`n"
    
    ; Build result message
    resultMsg := "Window Handle: " clickedWin "`n"
    resultMsg .= "Window Class: " windowClass "`n"
    resultMsg .= "Window Title: " windowTitle "`n"
    resultMsg .= "Window Style: " Format("0x{:X}", windowStyle) "`n`n"
    
    if (isValid)
        resultMsg .= "RESULT: Window IS valid for resizing"
    else {
        resultMsg .= "RESULT: Window is NOT valid for resizing`n`n"
        resultMsg .= "Reasons:`n" reason
    }
    
    ; Display result
    MsgBox(resultMsg, "Window Validation Result")
    
}

; Start the application
; AnalyzeWindow()
