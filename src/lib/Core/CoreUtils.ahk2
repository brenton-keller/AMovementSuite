
CheckForKeyRelease() {
    global scalingModeActive

    static wasReleased := true
    
    ; If RButton is not pressed, reset the scaling state
    if (!GetKeyState("RButton", "P")) {
        if (scalingModeActive) {
            scalingModeActive := false
            wasReleased := true
            ToolTip  ; Clear any tooltips
        }
    } else if (scalingModeActive && wasReleased) {
        wasReleased := false
    }
}

InitSafetyTimer() {
    ; Set a timer to check for key release in case of errors
    SetTimer(CheckForKeyRelease, 250)
}

InitSafetyTimer()

ShowWindowMoveSettings(*) {
    global enableWindowSnapping, snapDistance
    
    ; Create the settings window
    settingsGui := Gui("+AlwaysOnTop +ToolWindow", "Window Move Settings")
    
    ; Add checkbox for window snapping
    settingsGui.Add("CheckBox", "vWindowSnapping Checked" enableWindowSnapping, "Enable Window Snapping")
    
    ; Add snap distance slider
    settingsGui.Add("Text", "xm y+15", "Snap Distance (pixels):")
    settingsGui.Add("Slider", "vSnapDistance Range1-25 TickInterval5 Tooltip w200", snapDistance)
    
    ; Show current value
    settingsGui.Add("Text", "x+5 w30 vCurrentValue", snapDistance)
    
    ; Add buttons
    settingsGui.Add("Button", "xm y+15 w80 Default", "OK").OnEvent("Click", SaveSettings)
    settingsGui.Add("Button", "x+10 w80", "Cancel").OnEvent("Click", CloseSettings)
    
    ; Event for updating the displayed value
    sliderControl := settingsGui["SnapDistance"]
    sliderControl.OnEvent("Change", UpdateValue)
    
    ; Show the GUI
    settingsGui.Show()
    
    UpdateValue(*) {
        settingsGui["CurrentValue"].Value := sliderControl.Value
    }
    
    SaveSettings(*) {
        Saved := settingsGui.Submit()
        enableWindowSnapping := Saved.WindowSnapping
        snapDistance := Saved.SnapDistance
        settingsGui.Destroy()
    }
    
    CloseSettings(*) {
        settingsGui.Destroy()
    }
}

ShowProgramPathsConfig(*) {
    ; Get current status of all configured programs
    status := ProgramPaths.GetStatus()

    ; Create the settings window
    pathsGui := Gui("+AlwaysOnTop +Resize", "Program Paths Configuration")
    pathsGui.SetFont("s10")

    ; Title text
    pathsGui.Add("Text", "w500", "Detected Program Paths")
    pathsGui.Add("Text", "w500", "âœ“ = Found  |  âœ— = Not Found")
    pathsGui.Add("Text", "w500", "")  ; Spacer

    ; Display each program's status
    yPos := 80
    for name, info in status {
        ; Status indicator
        indicator := info.exists ? "âœ“" : "âœ—"
        color := info.exists ? "Green" : "Red"

        ; Program name
        pathsGui.SetFont("Bold")
        pathsGui.Add("Text", "x20 y" yPos " w100", name ":")
        pathsGui.SetFont()

        ; Status
        pathsGui.SetFont("c" color " Bold")
        pathsGui.Add("Text", "x+10 w30", indicator)
        pathsGui.SetFont()

        ; Path
        pathsGui.Add("Edit", "x+10 w400 ReadOnly", info.path)

        yPos += 35
    }

    ; Spacer
    pathsGui.Add("Text", "xm y" yPos " w500", "")
    yPos += 10

    ; Instructions
    pathsGui.SetFont("s9 Italic")
    pathsGui.Add("Text", "xm y" yPos " w500",
        "To customize paths for this machine:")
    pathsGui.Add("Text", "xm y+" yPos " w500",
        "1. Copy: src\lib\Config\UserConfig.template.ahk2")
    pathsGui.Add("Text", "xm y+" yPos " w500",
        "2. To: src\lib\Config\UserConfig.local.ahk2")
    pathsGui.Add("Text", "xm y+" yPos " w500",
        "3. Edit UserConfig.local.ahk2 with your custom paths")
    pathsGui.Add("Text", "xm y+" yPos " w500",
        "4. Reload this script")
    pathsGui.SetFont()

    yPos += 110

    ; Buttons
    pathsGui.Add("Button", "xm y" yPos " w120 Default", "Open Config Folder").OnEvent("Click", OpenConfigFolder)
    pathsGui.Add("Button", "x+10 w120", "Reload Script").OnEvent("Click", ReloadScript)
    pathsGui.Add("Button", "x+10 w120", "Close").OnEvent("Click", (*) => pathsGui.Destroy())

    ; Show the GUI
    pathsGui.Show("w560 h" (yPos + 50))

    OpenConfigFolder(*) {
        Run 'explorer.exe "' A_ScriptDir '\src\lib\Config"'
    }

    ReloadScript(*) {
        Reload
    }
}

GetWindowMonitor(winX, winY, winWidth, winHeight) {
    ; Use virtual monitor API for PBP support
    return GetVirtualMonitorForWindow(winX, winY, winWidth, winHeight)
}

IsValidWindowForResize(hwnd) {
    ; Check if window still exists
    if (!hwnd || !WinExist("ahk_id " hwnd))
        return false

    ; Get window class
    windowClass := WinGetClass("ahk_id " hwnd)
    
    ; List of classes to exclude (add more as needed)
    excludedClasses := [
        "#32768",    ; Standard Windows context menus
        "Windows.UI.Core.CoreWindow",  ; Modern context menus
        "ToolbarWindow32"
        "DropDown",
        "Popup",
        "PopupMenu"
    ]
    
    ; ; Check if window is excluded
    for excludedClass in excludedClasses {
        if (windowClass = excludedClass)
            return false
    }
    
    ; Additional checks
    if (!WinGetTitle("ahk_id " hwnd))  ; No title usually means temporary window
        return false
        
    if (WinGetStyle("ahk_id " hwnd) & 0x40000000)  ; Check if it's a child window
        return false
    
    return true
}

GetMonitorAtPos(x, y) {
    ; Use virtual monitor API for PBP support
    return GetVirtualMonitorFromPoint(x, y)
}

; When script starts, enter "click to analyze" mode
AnalyzeWindow() {
    ; Show instruction message
    MsgBox("Click on a window to analyze whether it's valid for resizing.", "Window Validator")
    
    ; Make sure we start with mouse released
    KeyWait "LButton"
    
    ; Then wait for a click
    KeyWait "LButton", "D"
    Sleep 100  ; Small delay to ensure click registers fully
    
    ; Get the window under the cursor
    MouseGetPos(, , &clickedWin)
    
    ; Get window info
    windowClass := WinGetClass("ahk_id " clickedWin)
    windowTitle := WinGetTitle("ahk_id " clickedWin)
    windowStyle := WinGetStyle("ahk_id " clickedWin)
    
    ; Check validity
    isValid := IsValidWindowForMove(clickedWin)
    
    ; Determine why it might be invalid
    reason := ""
    
    ; Check if window is in excluded classes
    excludedClasses := [
        "#32768",    ; Standard Windows context menus
        "Windows.UI.Core.CoreWindow",  ; Modern context menus
        "ToolbarWindow32",
        "DropDown",
        "Popup",
        "PopupMenu"
    ]
    
    for excludedClass in excludedClasses {
        if (windowClass = excludedClass) {
            reason .= "â€¢ Window class is in exclusion list: " excludedClass "`n"
            break
        }
    }
    
    ; Check title
    if (!windowTitle)
        reason .= "â€¢ Window has no title`n"
    
    ; Check if child window
    if (windowStyle & 0x40000000)
        reason .= "â€¢ Window is a child window (WS_CHILD style detected)`n"
    
    ; Build result message
    resultMsg := "Window Handle: " clickedWin "`n"
    resultMsg .= "Window Class: " windowClass "`n"
    resultMsg .= "Window Title: " windowTitle "`n"
    resultMsg .= "Window Style: " Format("0x{:X}", windowStyle) "`n`n"
    
    if (isValid)
        resultMsg .= "RESULT: Window IS valid for resizing"
    else {
        resultMsg .= "RESULT: Window is NOT valid for resizing`n`n"
        resultMsg .= "Reasons:`n" reason
    }
    
    ; Display result
    MsgBox(resultMsg, "Window Validation Result")
    
}

; Start the application
; AnalyzeWindow()

; ============================================================================
; Shared Debug/Notification Utilities
; ============================================================================

; Simple debug tooltip message
ShowDebugMessage(message) {
    ToolTip message
    SetTimer () => ToolTip(), -2000
}

; ============================================================================
; Shared Action Notification System
; High-quality GUI notifications for window actions
; ============================================================================

/** ShowActionNotification
 * Displays a polished GUI notification for window actions.
 *
 * @param {String} action - The action type: "pinned", "unpinned", "sent_back",
 *                          "minimized", "grouped", "ungrouped", "group_select",
 *                          "group_offset", "error"
 * @param {String} message - Optional custom message (overrides default)
 * @param {String} winTitle - Optional window title to display
 * @param {Object} options - Optional settings: {duration: ms, position: "center"|"cursor"}
 *
 * @returns {void}
 */
ShowActionNotification(action, message := "", winTitle := "", options := {}) {
    static notifGui := ""
    static iconMap := Map(
        "pinned",       {icon: "ðŸ“Œ", color: "22c55e", defaultMsg: "Pinned to Top"},
        "unpinned",     {icon: "ðŸ“Œ", color: "ef4444", defaultMsg: "Unpinned"},
        "sent_back",    {icon: "â¬‡",  color: "3b82f6", defaultMsg: "Sent to Back"},
        "minimized",    {icon: "âž–", color: "8b5cf6", defaultMsg: "Minimized"},
        "grouped",      {icon: "ðŸ”—", color: "22c55e", defaultMsg: "Windows Grouped"},
        "ungrouped",    {icon: "ðŸ”“", color: "f59e0b", defaultMsg: "Group Cleared"},
        "group_select", {icon: "ðŸ‘†", color: "3b82f6", defaultMsg: "Window Selected"},
        "group_offset", {icon: "â†”",  color: "22c55e", defaultMsg: "Offset Updated"},
        "error",        {icon: "âœ—",  color: "ef4444", defaultMsg: "Error"},
        "success",      {icon: "âœ“",  color: "22c55e", defaultMsg: "Success"},
        "info",         {icon: "â„¹",  color: "3b82f6", defaultMsg: "Info"}
    )

    ; Get icon info for this action
    iconInfo := iconMap.Has(action) ? iconMap[action] : iconMap["info"]

    ; Destroy previous notification if it exists
    if (notifGui) {
        try notifGui.Destroy()
        notifGui := ""
    }

    ; Determine message to display
    displayMsg := message ? message : iconInfo.defaultMsg

    ; Create notification GUI
    notifGui := Gui("+ToolWindow -Caption +AlwaysOnTop +E0x20")
    notifGui.BackColor := "1a1a1a"

    ; Icon on the left
    notifGui.SetFont("s20", "Segoe UI Emoji")
    notifGui.Add("Text", "x15 y12 w40 h40 c" iconInfo.color, iconInfo.icon)

    ; Main message
    notifGui.SetFont("s13 Bold", "Segoe UI")
    notifGui.Add("Text", "x55 y15 w300 c" iconInfo.color, displayMsg)

    ; Window title (if provided)
    if (winTitle) {
        ; Truncate long titles
        displayTitle := StrLen(winTitle) > 40 ? SubStr(winTitle, 1, 37) "..." : winTitle
        notifGui.SetFont("s10 Norm", "Segoe UI")
        notifGui.Add("Text", "x55 y40 w300 ccccccc", displayTitle)
    }

    ; Calculate dimensions
    guiWidth := 370
    guiHeight := winTitle ? 75 : 50

    ; Position
    posType := options.HasOwnProp("position") ? options.position : "center"
    if (posType = "cursor") {
        MouseGetPos &mx, &my
        posX := mx - guiWidth // 2
        posY := my - guiHeight - 20
    } else {
        posX := (A_ScreenWidth - guiWidth) // 2
        posY := (A_ScreenHeight - guiHeight) // 2
    }

    ; Show with transparency
    notifGui.Show("x" posX " y" posY " w" guiWidth " h" guiHeight " NoActivate")
    WinSetTransparent 240, notifGui.Hwnd

    ; Auto-dismiss
    duration := options.HasOwnProp("duration") ? options.duration : 1800
    SetTimer () => (notifGui ? (notifGui.Destroy(), notifGui := "") : ""), -duration
}
