/** GetWindowVisualPos
 * Gets the actual visual frame bounds of a window, excluding invisible DWM borders.
 * Uses DwmGetWindowAttribute with DWMWA_EXTENDED_FRAME_BOUNDS to get the true visible window area.
 * Falls back to WinGetPos if DWM API fails.
 *
 * @param {String|Integer} winTitle Window title or handle (e.g., "ahk_id " hwnd)
 * @param {VarRef} &x Output variable for X-coordinate
 * @param {VarRef} &y Output variable for Y-coordinate
 * @param {VarRef} &width Output variable for width
 * @param {VarRef} &height Output variable for height
 * @returns {Boolean} True if successful, false otherwise
 *
 * @example
 * GetWindowVisualPos("ahk_id " activeWin, &x, &y, &w, &h)
 */
GetWindowVisualPos(winTitle, &x, &y, &width, &height) {
    ; Get window handle
    hwnd := WinExist(winTitle)
    if (!hwnd) {
        x := y := width := height := ""
        return false
    }

    ; Try to get visual frame bounds via DWM API
    ; DWMWA_EXTENDED_FRAME_BOUNDS = 9
    RECT := Buffer(16, 0)  ; RECT structure = 4 LONGs (16 bytes)
    result := DllCall("dwmapi\DwmGetWindowAttribute"
        , "Ptr", hwnd
        , "UInt", 9  ; DWMWA_EXTENDED_FRAME_BOUNDS
        , "Ptr", RECT
        , "UInt", 16
        , "UInt")

    if (result = 0) {  ; S_OK
        ; Extract RECT values (left, top, right, bottom)
        x := NumGet(RECT, 0, "Int")
        y := NumGet(RECT, 4, "Int")
        right := NumGet(RECT, 8, "Int")
        bottom := NumGet(RECT, 12, "Int")
        width := right - x
        height := bottom - y
        return true
    }

    ; Fallback to WinGetPos if DWM API fails
    try {
        WinGetPos(&x, &y, &width, &height, winTitle)
        return true
    } catch {
        x := y := width := height := ""
        return false
    }
}

/** GetDWMOffset
 * Calculates the offset between visual coordinates and DWM coordinates for a window.
 * This offset can be used to convert visual positions to DWM positions for WinMove.
 *
 * @param {String|Integer} winTitle Window title or handle (e.g., "ahk_id " hwnd)
 * @param {VarRef} &offsetX Output variable for X offset (DWM_x - Visual_x)
 * @param {VarRef} &offsetY Output variable for Y offset (DWM_y - Visual_y)
 * @returns {Boolean} True if successful, false otherwise
 *
 * @example
 * GetDWMOffset("ahk_id " activeWin, &ox, &oy)
 * WinMove(visualX + ox, visualY + oy, , , "ahk_id " activeWin)
 */
GetDWMOffset(winTitle, &offsetX, &offsetY) {
    ; Get visual position
    if (!GetWindowVisualPos(winTitle, &visualX, &visualY, &visualW, &visualH))
        return false

    ; Get DWM position
    try {
        WinGetPos(&dwmX, &dwmY, &dwmW, &dwmH, winTitle)
    } catch {
        return false
    }

    ; Calculate offsets
    offsetX := dwmX - visualX
    offsetY := dwmY - visualY

    return true
}

/** VisualToWinMove
 * Moves a window to a visual position by converting to DWM coordinates.
 * This ensures the visible part of the window appears at the specified coordinates.
 *
 * @param {String|Integer} winTitle Window title or handle
 * @param {Integer} visualX Desired visual X position
 * @param {Integer} visualY Desired visual Y position
 * @param {Integer} width Optional width (leave blank to keep current)
 * @param {Integer} height Optional height (leave blank to keep current)
 * @returns {Boolean} True if successful, false otherwise
 *
 * @example
 * VisualToWinMove("ahk_id " activeWin, 100, 100, 800, 600)
 */
VisualToWinMove(winTitle, visualX, visualY, width := "", height := "") {
    ; Get DWM offset for this window
    if (!GetDWMOffset(winTitle, &offsetX, &offsetY))
        return false

    ; Convert visual coordinates to DWM coordinates
    dwmX := visualX + offsetX
    dwmY := visualY + offsetY

    ; Move window using DWM coordinates
    try {
        if (width != "" && height != "")
            WinMove(dwmX, dwmY, width, height, winTitle)
        else
            WinMove(dwmX, dwmY, , , winTitle)
        return true
    } catch {
        return false
    }
}

/** VisualResize
 * Resizes a window using visual dimensions by converting to DWM dimensions.
 * This ensures the visible part of the window has the specified size.
 *
 * @param {String|Integer} winTitle Window title or handle
 * @param {Integer} visualWidth Desired visual width
 * @param {Integer} visualHeight Desired visual height
 * @param {Boolean} keepPosition If true, maintains visual position (default true)
 * @returns {Boolean} True if successful, false otherwise
 *
 * @example
 * VisualResize("ahk_id " activeWin, 800, 600)
 */
VisualResize(winTitle, visualWidth, visualHeight, keepPosition := true) {
    ; Get current visual position
    if (!GetWindowVisualPos(winTitle, &visualX, &visualY, &currentVisualW, &currentVisualH))
        return false

    ; Get DWM dimensions
    try {
        WinGetPos(&dwmX, &dwmY, &dwmW, &dwmH, winTitle)
    } catch {
        return false
    }

    ; Calculate DWM border sizes
    borderX := (dwmW - currentVisualW) / 2
    borderY := (dwmH - currentVisualH) / 2

    ; Convert visual dimensions to DWM dimensions
    newDwmWidth := visualWidth + (borderX * 2)
    newDwmHeight := visualHeight + (borderY * 2)

    ; If keeping position, adjust DWM position to maintain visual position
    if (keepPosition) {
        if (!GetDWMOffset(winTitle, &offsetX, &offsetY))
            return false
        newDwmX := visualX + offsetX
        newDwmY := visualY + offsetY

        try {
            WinMove(newDwmX, newDwmY, newDwmWidth, newDwmHeight, winTitle)
            return true
        } catch {
            return false
        }
    } else {
        ; Just resize without moving
        try {
            WinMove(, , newDwmWidth, newDwmHeight, winTitle)
            return true
        } catch {
            return false
        }
    }
}

/** GetValidWindows
 * Returns an array of valid window handles that can be manipulated.
 * Handles errors gracefully - skips windows that throw access denied.
 *
 * @param {Integer} excludeHwnd Optional window handle to exclude from results
 * @returns {Array} Array of valid window handles (hwnds)
 */
GetValidWindows(excludeHwnd := 0) {
    ; Save current state and disable hidden window detection
    prevDetectHidden := A_DetectHiddenWindows
    DetectHiddenWindows false

    validWindows := []
    windowList := WinGetList()

    ; Get our own script's PID to exclude our windows
    scriptPID := ProcessExist()

    for hwnd in windowList {
        try {
            ; Skip excluded window
            if (excludeHwnd && hwnd == excludeHwnd)
                continue

            ; Skip our own script's windows
            if (WinGetPID("ahk_id " hwnd) == scriptPID)
                continue

            ; Skip if window isn't valid for our purposes
            if (!IsValidWindowForMove(hwnd))
                continue

            ; Skip windows that don't exist anymore
            if (!WinExist("ahk_id " hwnd))
                continue

            ; Get position and skip windows with invalid positions
            WinGetPos(&x, &y, &w, &h, "ahk_id " hwnd)
            if (x == "" || y == "" || w == "" || h == "")
                continue

            validWindows.Push(hwnd)
        } catch {
            ; Skip windows that throw errors (elevated, system, etc.)
            continue
        }
    }

    ; Restore previous state
    DetectHiddenWindows prevDetectHidden

    return validWindows
}

/** MonitorFromPoint
 * Determines which monitor contains a specified point (x,y) coordinate.
 * Now supports virtual monitors for PBP mode.
 *
 * @param x The x-coordinate to check
 * @param y The y-coordinate to check
 *
 * @returns {Integer} The monitor index that contains the point,
 *          or the primary monitor index if the point is not on any monitor
 */
MonitorFromPoint(x, y) {
    ; Use virtual monitor API for PBP support
    return GetVirtualMonitorFromPoint(x, y)
}

/**
 * IsValidWindowForMove
 * Checks if a window can be moved by the window management script.
 * Prevents modification of system windows, dialogs, minimized windows,
 * and windows running with administrative privileges.
 * 
 * @param hwnd The window handle to check
 * 
 * @returns {Boolean} True if the window can be moved, false otherwise
 * 
 * @example
 * if (IsValidWindowForMove(WinExist("A")))
 *     MsgBox "This window can be moved!"
 */
; IsValidWindowForMove(hwnd) { ; Check if the window is valid for moving
;     if (!hwnd)
;         return false
        
;     ; Don't allow moving certain system windows
;     windowClass := WinGetClass("ahk_id " hwnd)
    
;     ; List of classes that shouldn't be moved
;     excludedClasses := ["Progman", "WorkerW", "Shell_TrayWnd", "Windows.UI.Core.CoreWindow"]
    
;     for class in excludedClasses {
;         if (windowClass == class)
;             return false
;     }
    
;     ; Get process info
;     exeName := WinGetProcessName("ahk_id " hwnd)
    
;     ; Explicitly check for Task Manager and other known elevated programs
;     if (exeName = "Taskmgr.exe" || windowClass = "TaskManagerWindow")
;         return false
        
;     ; List of specific executable names that are typically elevated
;     elevatedExes := ["mmc.exe", "gpedit.msc", "regedit.exe", "secpol.msc", "services.msc"]
;     for exe in elevatedExes {
;         if (exeName = exe)
;             return false
;     }
    
;     ; Check if the window has a shield icon (UAC shield) in its title bar
;     ; This is a simple heuristic that many admin windows have
;     title := WinGetTitle("ahk_id " hwnd)
;     if (title ~= "i)(Administrator|Elevated|as Admin)")
;         return false
    
;     ; Check if the window is a system dialog
;     if (WinGetStyle("ahk_id " hwnd) & 0x08000000) { ; WS_POPUP
;         if (title ~= "i)^(Error|Warning|Info|Confirm|Prompt)")
;             return false
;     }
    
;     ; Check if window can be moved (not minimized)
;     minMax := WinGetMinMax("ahk_id " hwnd)
;     if (minMax == -1) ; Window is minimized
;         return false
    
;     ; Try to detect elevated windows by checking if we can modify a window property
;     ; This is a good heuristic for detecting admin windows
;     try {
;         ; Try to get a system menu - this will often fail for elevated windows when script isn't elevated
;         hSysMenu := DllCall("GetSystemMenu", "Ptr", hwnd, "Int", false)
;         if (!hSysMenu)
;             return false
        
;         ; Try to modify window style (but immediately restore it)
;         currentStyle := WinGetStyle("ahk_id " hwnd)
;         result := DllCall("SetWindowLong" (A_PtrSize=8?"Ptr":""), "Ptr", hwnd, "Int", -16, "Ptr", currentStyle)
;         if (result = 0) ; This will fail for elevated windows when script is not elevated
;             return false
;     } catch {
;         ; If any access is denied, assume it's an elevated window
;         return false
;     }
        
;     return true
; }

/** IsWindowChildOf
 * Determines if a window is a child or owned by another window.
 * 
 * @param {Ptr} childHwnd Handle of the potential child window
 * @param {Ptr} parentHwnd Handle of the potential parent window
 * 
 * @returns {Boolean} True if the child window is a direct child or owned by the parent window
 * 
 * @example
 * isChild := IsWindowChildOf(childWindow, parentWindow)
 */
IsWindowChildOf(childHwnd, parentHwnd) {
    try {
        parentWindow := DllCall("GetParent", "Ptr", childHwnd, "Ptr")
        if (parentWindow && parentWindow == parentHwnd)
            return true
            
        ; Also check for owner relationship
        ownerWindow := DllCall("GetWindow", "Ptr", childHwnd, "UInt", 4, "Ptr") ; GW_OWNER = 4
        if (ownerWindow && ownerWindow == parentHwnd)
            return true
    }
    catch {
        return false
    }
    return false
}

/** GetWindowEdges
 * Retrieves a list of edges from all visible windows, excluding certain system windows.
 * 
 * @param {Ptr} excludeHwnd Window handle to exclude from edge collection
 * 
 * @returns {Array} List of window edges with type, position, title, and handle
 * 
 * @example
 * windowEdges := GetWindowEdges(currentWindowHandle)
 */
GetWindowEdges(excludeHwnd) {
    edges := []
    
    ; Get all windows
    hwnd := WinGetList(,, "Program Manager")
    
    Loop hwnd.Length {
        current := hwnd[A_Index]
        
        ; Skip the window being moved
        if (current == excludeHwnd)
            continue
            
        ; Skip if window no longer exists
        if (!WinExist("ahk_id " current))
            continue
        
        ; Get more details about the window for better filtering
        try {
            ; Skip if minimized, invisible, or has zero size
            if (WinGetMinMax("ahk_id " current) == -1)
                continue
                
            ; Skip system windows and special windows
            windowClass := WinGetClass("ahk_id " current)
            windowTitle := WinGetTitle("ahk_id " current)
            windowStyle := WinGetStyle("ahk_id " current)
            windowExStyle := WinGetExStyle("ahk_id " current)
            
            ; Skip windows that are likely not relevant for snapping
            if (windowClass ~= "i)^(Progman|WorkerW|Shell_TrayWnd|Windows\.UI\.Core\.CoreWindow|DV2ControlHost|BaseBar|NotifyIconOverflowWindow)$")
                continue
                
            ; Skip windows with certain attributes
            if (!(windowStyle & 0x10000000)) ; WS_VISIBLE
                continue
                
            if (windowExStyle & 0x00000080) ; WS_EX_TOOLWINDOW (skip tool windows)
                continue
                
            ; Skip windows with empty titles (likely system windows)
            if (windowTitle == "")
                continue
                
            ; Get window position (use visual bounds for accurate snapping)
            if (!GetWindowVisualPos("ahk_id " current, &wx, &wy, &ww, &wh))
                continue
            if (ww < 50 || wh < 50)  ; Skip tiny windows (likely not main app windows)
                continue
                
            ; Add window edges with title for feedback
            title := windowTitle ? windowTitle : "Window"
                
            ; Create edge objects with window handle included
            edges.Push({type: "left", position: wx, title: title, hwnd: current})
            edges.Push({type: "right", position: wx + ww, title: title, hwnd: current})
            edges.Push({type: "top", position: wy, title: title, hwnd: current})
            edges.Push({type: "bottom", position: wy + wh, title: title, hwnd: current})
        }
        catch {
            ; Skip this window if any error occurs while getting its properties
            continue
        }
    }
    
    return edges
}

/** ProcessWindowSnapping
 * Calculates window snapping based on proximity to other window edges,
 * but only when windows have overlapping regions.
 * 
 * @param {Integer} x X-coordinate of the window
 * @param {Integer} y Y-coordinate of the window
 * @param {Integer} width Width of the window
 * @param {Integer} height Height of the window
 * @param {Array} edges List of window edges to snap against
 * 
 * @returns {Object} Snapping result with updated coordinates and snapping status
 */
ProcessWindowSnapping(x, y, width, height, edges) {
    result := {snapped: false, x: x, y: y, message: ""}
    
    ; Group edges by their parent window
    windowEdges := Map()
    for edge in edges {
        if !windowEdges.Has(edge.hwnd)
            windowEdges[edge.hwnd] := {title: edge.title, edges: []}
        
        windowEdges[edge.hwnd].edges.Push(edge)
    }
    
    ; Check each window for possible snapping
    for hwnd, window in windowEdges {
        ; Extract window dimensions from its edges
        targetWindow := {left: 0, right: 0, top: 0, bottom: 0}
        
        for edge in window.edges {
            if (edge.type == "left")
                targetWindow.left := edge.position
            else if (edge.type == "right")
                targetWindow.right := edge.position
            else if (edge.type == "top")
                targetWindow.top := edge.position
            else if (edge.type == "bottom")
                targetWindow.bottom := edge.position
        }
        
        ; Current window dimensions
        currentWindow := {
            left: x,
            right: x + width,
            top: y,
            bottom: y + height
        }
        
        ; Check for horizontal overlap (for vertical snapping)
        horizontalOverlap := !(currentWindow.right < targetWindow.left || currentWindow.left > targetWindow.right)
        
        ; Check for vertical overlap (for horizontal snapping)
        verticalOverlap := !(currentWindow.bottom < targetWindow.top || currentWindow.top > targetWindow.bottom)
        
        ; Check edges for snapping, but only if there's appropriate overlap
        for edge in window.edges {
            ; For horizontal edges (top/bottom), require horizontal overlap
            if ((edge.type == "top" || edge.type == "bottom") && horizontalOverlap) {
                ; Check top edge of current window to this edge
                if (Abs(y - edge.position) < snapDistance) {
                    result.y := edge.position
                    result.snapped := true
                    result.message := result.message ? result.message ", Top" : "Top to " window.title " " edge.type
                    break
                }
                
                ; Check bottom edge of current window to this edge
                if (Abs(y + height - edge.position) < snapDistance) {
                    result.y := edge.position - height
                    result.snapped := true
                    result.message := result.message ? result.message ", Bottom" : "Bottom to " window.title " " edge.type
                    break
                }
            }
            
            ; For vertical edges (left/right), require vertical overlap
            if ((edge.type == "left" || edge.type == "right") && verticalOverlap) {
                ; Check left edge of current window to this edge
                if (Abs(x - edge.position) < snapDistance) {
                    result.x := edge.position
                    result.snapped := true
                    result.message := "Left to " window.title " " edge.type
                    break
                }
                
                ; Check right edge of current window to this edge
                if (Abs(x + width - edge.position) < snapDistance) {
                    result.x := edge.position - width
                    result.snapped := true
                    result.message := "Right to " window.title " " edge.type
                    break
                }
            }
        }
        
        ; If we've snapped, no need to check other windows
        if (result.snapped)
            break
    }
    
    return result
}

ProcessWindowSnappingForResize(newX, y, newW, height, edges, snapDistance, isNearLeftEdge, isNearRightEdge) {
    result := {snapped: false, x: newX, width: newW}

    ; If neither edge is being actively resized, just return
    if (!isNearLeftEdge && !isNearRightEdge)
        return result

    currentLeft := newX
    currentRight := newX + newW

    ; Group edges by parent window
    windowEdges := Map()
    for edge in edges {
        if !windowEdges.Has(edge.hwnd)
            windowEdges[edge.hwnd] := {title: edge.title, edges: []}
        
        windowEdges[edge.hwnd].edges.Push(edge)
    }

    for hwnd, window in windowEdges {
        ; Determine the bounding box of this other window from its edges
        targetWindow := {left: 0, right: 0, top: 0, bottom: 0}
        for edge in window.edges {
            if (edge.type == "left")
                targetWindow.left := edge.position
            else if (edge.type == "right")
                targetWindow.right := edge.position
            else if (edge.type == "top")
                targetWindow.top := edge.position
            else if (edge.type == "bottom")
                targetWindow.bottom := edge.position
        }
        
        ; Find overlap in vertical dimension so we only snap if the windows
        ; have some overlapping region vertically
        thisTop    := y
        thisBottom := y + height
        thatTop    := targetWindow.top
        thatBottom := targetWindow.bottom
        
        verticalOverlap := !(thisBottom < thatTop || thisTop > thatBottom)
        if (!verticalOverlap)
            continue
        
        ; Now check horizontal edges for snapping
        for edge in window.edges {
            if (edge.type == "left" || edge.type == "right") {
                ; The other window's edge position
                targetPos := edge.position
                
                ; Snap left edge if we are resizing from the left
                if (isNearLeftEdge) {
                    ; If our new left edge is within snapDistance of targetPos
                    if (Abs(currentLeft - targetPos) < snapDistance) {
                        result.x := targetPos
                        result.width := currentRight - targetPos  ; keep right the same
                        result.snapped := true
                        return result
                    }
                }
                
                ; Snap right edge if we are resizing from the right
                if (isNearRightEdge) {
                    ; If our new right edge is within snapDistance of targetPos
                    if (Abs(currentRight - targetPos) < snapDistance) {
                        ; new width = targetPos - left
                        result.width := targetPos - currentLeft
                        result.snapped := true
                        return result
                    }
                }
            }
        }
    }

    return result
}

/** ProcessScreenSnapping
 * Calculates window snapping based on proximity to screen edges.
 * 
 * @param {Integer} x X-coordinate of the window
 * @param {Integer} y Y-coordinate of the window
 * @param {Integer} width Width of the window
 * @param {Integer} height Height of the window
 * @param {Integer} left Left boundary of the screen
 * @param {Integer} top Top boundary of the screen
 * @param {Integer} right Right boundary of the screen
 * @param {Integer} bottom Bottom boundary of the screen
 * 
 * @returns {Object} Snapping result with updated coordinates and snapping status
 * 
 * @example
 * screenSnapResult := ProcessScreenSnapping(windowX, windowY, windowWidth, windowHeight, monitorLeft, monitorTop, monitorRight, monitorBottom)
 */
ProcessScreenSnapping(x, y, width, height, left, top, right, bottom) {
    result := {snapped: false, x: x, y: y, message: ""}
    
    ; Left edge snapping
    if (Abs(x - left) < snapDistance) {
        result.x := left
        result.snapped := true
        result.message := "Screen Left"
    }
    
    ; Right edge snapping
    if (Abs(x + width - right) < snapDistance) {
        result.x := right - width
        result.snapped := true
        result.message := "Screen Right"
    }
    
    ; Top edge snapping
    if (Abs(y - top) < snapDistance) {
        result.y := top
        result.snapped := true
        result.message := result.message ? result.message ", Top" : "Screen Top"
    }
    
    ; Bottom edge snapping
    if (Abs(y + height - bottom) < snapDistance) {
        result.y := bottom - height
        result.snapped := true
        result.message := result.message ? result.message ", Bottom" : "Screen Bottom"
    }
    
    ; ; Center horizontally
    ; centerX := left + (right - left) / 2 - width / 2
    ; if (Abs(x - centerX) < snapDistance) {
    ;     result.x := Round(centerX)
    ;     result.snapped := true
    ;     result.message := result.message ? result.message ", Center H" : "Screen Center H"
    ; }
    
    ; ; Center vertically
    ; centerY := top + (bottom - top) / 2 - height / 2
    ; if (Abs(y - centerY) < snapDistance) {
    ;     result.y := Round(centerY)
    ;     result.snapped := true
    ;     result.message := result.message ? result.message ", Center V" : "Screen Center V"
    ; }
    
    return result
}

/** FindSnappedWindows
 * Identifies windows that are closely aligned with the main window.
 * 
 * @param {Ptr} mainWinHwnd Handle of the main window
 * @param {Integer} mainX X-coordinate of the main window
 * @param {Integer} mainY Y-coordinate of the main window
 * @param {Integer} mainWidth Width of the main window
 * @param {Integer} mainHeight Height of the main window
 * @param {Array} allWindowEdges List of all window edges
 * 
 * @returns {Array} List of window handles that are snapped to the main window
 * 
 * @example
 * snappedWindows := FindSnappedWindows(activeWindowHandle, windowX, windowY, windowWidth, windowHeight, windowEdges)
 */
FindSnappedWindows(mainWinHwnd, mainX, mainY, mainWidth, mainHeight, allWindowEdges) {
    snappedWindows := []
    snapTolerance := 5  ; How close windows need to be to be considered "snapped" (in pixels)
    
    ; Define the edges of our main window
    mainLeft := mainX
    mainRight := mainX + mainWidth
    mainTop := mainY
    mainBottom := mainY + mainHeight
    
    ; Find windows with edges that align with our main window
    processedWindows := Map()  ; Track windows we've already added
    
    ; Group edges by window handle for easier checking
    windowEdgesByHwnd := Map()
    
    for edge in allWindowEdges {
        if (!windowEdgesByHwnd.Has(edge.hwnd))
            windowEdgesByHwnd[edge.hwnd] := []
        
        windowEdgesByHwnd[edge.hwnd].Push(edge)
    }
    
    ; Check each window's edges against our main window
    for hwnd, edges in windowEdgesByHwnd {
        ; Skip our main window and already processed windows
        if (hwnd == mainWinHwnd || processedWindows.Has(hwnd))
            continue
        
        isSnapped := false
        
        ; Get this window's coordinates
        WinGetPos &wx, &wy, &ww, &wh, "ahk_id " hwnd
        otherLeft := wx
        otherRight := wx + ww
        otherTop := wy
        otherBottom := wy + wh
        
        ; Check horizontal alignment
        if (Abs(mainRight - otherLeft) <= snapTolerance || 
            Abs(mainLeft - otherRight) <= snapTolerance || 
            Abs(mainLeft - otherLeft) <= snapTolerance || 
            Abs(mainRight - otherRight) <= snapTolerance) {
            ; Check if there's vertical overlap
            if ((mainTop <= otherBottom && mainBottom >= otherTop) ||
                Abs(mainBottom - otherTop) <= snapTolerance || 
                Abs(mainTop - otherBottom) <= snapTolerance) {
                isSnapped := true
            }
        }
        
        ; Check vertical alignment
        if (Abs(mainBottom - otherTop) <= snapTolerance ||
            Abs(mainTop - otherBottom) <= snapTolerance ||
            Abs(mainTop - otherTop) <= snapTolerance ||
            Abs(mainBottom - otherBottom) <= snapTolerance) {
            ; Check if there's horizontal overlap
            if ((mainLeft <= otherRight && mainRight >= otherLeft) ||
                Abs(mainRight - otherLeft) <= snapTolerance || 
                Abs(mainLeft - otherRight) <= snapTolerance) {
                isSnapped := true
            }
        }
        
        if (isSnapped) {
            snappedWindows.Push(hwnd)
            processedWindows[hwnd] := true
        }
    }
    
    return snappedWindows
}

/** FindWindowsSnappedToBorder
 * Identifies windows that are snapped to a specific border of the main window.
 * 
 * @param {String} mainBorder Which border of the main window to check ("top", "bottom", "left", "right")
 * @param {Ptr} mainWinHwnd Handle of the main window
 * @param {Integer} mainX X-coordinate of the main window
 * @param {Integer} mainY Y-coordinate of the main window
 * @param {Integer} mainWidth Width of the main window
 * @param {Integer} mainHeight Height of the main window
 * @param {Array} allWindowEdges List of all window edges
 * 
 * @returns {Array} Array of objects {hwnd, border} where each object represents a window snapped to the specified border
 * 
 * @example
 * snappedWindows := FindWindowsSnappedToBorder("top", activeWindowHandle, windowX, windowY, windowWidth, windowHeight, windowEdges)
 */
FindWindowsSnappedToBorder(mainBorder, mainWinHwnd, mainX, mainY, mainWidth, mainHeight, allWindowEdges) {
    snappedWindows := []
    snapTolerance := 20
    
    ; ; Debug the window count first
    ; windowCount := Map()
    ; for edge in allWindowEdges {
    ;     if (edge.hwnd != mainWinHwnd && !windowCount.Has(edge.hwnd)) {
    ;         windowCount[edge.hwnd] := true
    ;     }
    ; }
    ; ToolTip("Checking " . windowCount.Count . " windows")
    ; SetTimer () => ToolTip(), -2000
    
    ; Define main window edges
    mainLeft := mainX
    mainRight := mainX + mainWidth
    mainTop := mainY
    mainBottom := mainY + mainHeight
    
    ; Group edges by window handle
    windowEdgesByHwnd := Map()
    for edge in allWindowEdges {
        if (!windowEdgesByHwnd.Has(edge.hwnd))
            windowEdgesByHwnd[edge.hwnd] := []
        
        windowEdgesByHwnd[edge.hwnd].Push(edge)
    }
    
    ; Process each window
    for hwnd, edges in windowEdgesByHwnd {
        if (hwnd == mainWinHwnd)
            continue
        
        ; Check if window exists before accessing it
        if (!WinExist("ahk_id " hwnd))
            continue
            
        ; Use try/catch to handle any errors with WinGetPos
        try {
            WinGetPos &wx, &wy, &ww, &wh, "ahk_id " hwnd
            
            ; Skip if we got invalid position values
            if (wx == "" || wy == "" || ww == "" || wh == "")
                continue
                
            otherLeft := wx
            otherRight := wx + ww
            otherTop := wy
            otherBottom := wy + wh
        } catch {
            ; Skip this window if any error occurs
            continue
        }
        
        ; Determine if snapped based on the mainBorder
        isSnapped := false
        snappedBorder := ""
        
        ; Check horizontal alignment for left/right borders
        if (mainBorder == "left" || mainBorder == "right") {
            if (Abs(mainLeft - otherRight) <= snapTolerance && 
                mainTop <= otherBottom && mainBottom >= otherTop) {
                if (mainBorder == "left") {
                    isSnapped := true
                    snappedBorder := "right"
                }
            }
            else if (Abs(mainRight - otherLeft) <= snapTolerance && 
                     mainTop <= otherBottom && mainBottom >= otherTop) {
                if (mainBorder == "right") {
                    isSnapped := true
                    snappedBorder := "left"
                }
            }
            ; else if (Abs(mainRight - otherRight) <= snapTolerance && 
            ;          mainTop <= otherBottom && mainBottom >= otherTop) {
            ;     if (mainBorder == "right") {
            ;         isSnapped := true
            ;         snappedBorder := "right"
            ;     }
            ; }
        }
        
        ; Similar checks for top/bottom if needed
        
        if (isSnapped) {
            try {
                title := WinGetTitle("ahk_id " hwnd)
            } catch {
                title := "Unknown"
            }
            snappedWindows.Push({hwnd: hwnd, border: snappedBorder, title: title})
        }
    }
    
    ; ; Debug info about what we found
    ; foundMsg := "Found " . snappedWindows.Length . " windows snapped to " . mainBorder
    ; ToolTip(foundMsg)
    ; SetTimer () => ToolTip(), -3000
    
    return snappedWindows
}

/** Highlights windows that are snapped to the specified border
 * @param {Array} snappedWindows Array of windows to highlight
 * @param {String} mainBorder The border that windows are snapped to
 * @returns {Array} Array of GUI objects for later cleanup
 */
HighlightSnappedWindows(snappedWindows, mainBorder) {
    ; Create a list to store our GUI objects
    highlightGuis := []
    
    ; Define colors for different border types
    borderColors := Map(
        "left", "0000FF",   ; Blue for left borders
        "right", "FF0000",  ; Red for right borders
        "top", "00FF00",    ; Green for top borders
        "bottom", "FF00FF"  ; Purple for bottom borders
    )
    
    ; Loop through each snapped window
    for snappedWindow in snappedWindows {
        hwnd := snappedWindow.hwnd
        snappedBorder := snappedWindow.border
        title := snappedWindow.title
        
        ; Get window position and size
        WinGetPos &wx, &wy, &ww, &wh, "ahk_id " hwnd
        
        ; Create a GUI to overlay this window
        MyGui := Gui("+AlwaysOnTop -Caption +ToolWindow +E0x20")
        MyGui.BackColor := "Black"
        MyGui.Opt("+LastFound")
        
        ; Make it semi-transparent
        WinSetTransparent(180)
        
        ; Add a border using the appropriate color
        borderColor := borderColors.Has(snappedBorder) ? borderColors[snappedBorder] : "FFFF00"
        borderWidth := 4
        
        ; Create colored border
        MyGui.Add("Progress", "x0 y0 w" ww " h" borderWidth " Background" borderColor)          ; Top
        MyGui.Add("Progress", "x0 y0 w" borderWidth " h" wh " Background" borderColor)          ; Left
        MyGui.Add("Progress", "x" ww-borderWidth " y0 w" borderWidth " h" wh " Background" borderColor)  ; Right
        MyGui.Add("Progress", "x0 y" wh-borderWidth " w" ww " h" borderWidth " Background" borderColor)  ; Bottom
        
        ; Add text showing the window title and border type
        infoText := title . " (" . snappedBorder . " border)"
        textOptions := "c" borderColor " BackgroundTrans Center"
        MyGui.Add("Text", "x" borderWidth " y" borderWidth+5 " w" ww-2*borderWidth " h30 " textOptions, infoText)
        
        ; Position the GUI over the window
        MyGui.Show("x" wx " y" wy " w" ww " h" wh " NoActivate")
        
        ; Store the GUI for later cleanup
        highlightGuis.Push(MyGui)
    }
    
    ; Create a summary GUI that shows the total count
    if (snappedWindows.Length > 0) {
        countGui := Gui("+AlwaysOnTop -Caption +ToolWindow")
        countGui.BackColor := "Black"
        countGui.SetFont("s14 cWhite", "Arial")
        countGui.Add("Text", "x10 y10", "Found " . snappedWindows.Length . " window(s) snapped to " . mainBorder . " edge")
        
        ; Position at bottom of screen (uses virtual monitors for PBP)
        VirtualMonitorGetWorkArea(GetVirtualMonitorPrimary(), &mX, &mY, &mW, &mH)
        countGui.Show("x" mX+10 " y" mH-60 " w400 h50 NoActivate")
        
        highlightGuis.Push(countGui)
    }
    
    ; Set a timer to remove the highlights after 5 seconds
    SetTimer(DestroyHighlights.Bind(highlightGuis), -5000)
    
    return highlightGuis
}

/** Destroys the highlight GUIs
 * @param {Array} guis Array of GUI objects to destroy
 */
DestroyHighlights(guis) {
    for gui in guis {
        gui.Destroy()
    }
}

/** ShowWindowPositioningGUI
 * Displays a GUI with window positioning options.
 * 
 * @param {Ptr} mwin Handle of the window to be positioned
 * @param {Integer} cursorX X-coordinate of the cursor
 * @param {Integer} cursorY Y-coordinate of the cursor
 * 
 * @returns {Object} GUI object with positioning buttons
 * 
 * @example
 * positioningGui := ShowWindowPositioningGUI(activeWindow, cursorX, cursorY)
 */
ShowWindowPositioningGUI(mwin, cursorX, cursorY) {
    global positioningGui
    
    ; Create the GUI
    positioningGui := Gui("-Caption +AlwaysOnTop")
    
    ; Add buttons in the specified layout
    positioningGui.buttons := []
    
    ; Row 1: Left 50% | Right 50%
    positioningGui.buttons.Push(positioningGui.Add("Button", "w100 h30 x10 y10", "Left 50%").OnEvent("Click", ButtonClick))
    positioningGui.buttons.Push(positioningGui.Add("Button", "w100 h30 x+5", "Right 50%").OnEvent("Click", ButtonClick))
    
    ; Row 2: Left 25% | Middle 50% | Right 25%
    positioningGui.buttons.Push(positioningGui.Add("Button", "w65 h30 x10 y+5", "Left 25%").OnEvent("Click", ButtonClick))
    positioningGui.buttons.Push(positioningGui.Add("Button", "w65 h30 x+5", "Middle 50%").OnEvent("Click", ButtonClick))
    positioningGui.buttons.Push(positioningGui.Add("Button", "w65 h30 x+5", "Right 25%").OnEvent("Click", ButtonClick))
    
    ; Row 3: Left 33% | Middle 33% | Right 33%
    positioningGui.buttons.Push(positioningGui.Add("Button", "w65 h30 x10 y+5", "Left 33%").OnEvent("Click", ButtonClick))
    positioningGui.buttons.Push(positioningGui.Add("Button", "w65 h30 x+5", "Middle 33%").OnEvent("Click", ButtonClick))
    positioningGui.buttons.Push(positioningGui.Add("Button", "w65 h30 x+5", "Right 33%").OnEvent("Click", ButtonClick))
    
    ; Calculate GUI size
    guiWidth := 215  ; Width for buttons plus margins
    guiHeight := 115  ; Height for three rows of buttons plus margins
    
    ; Get the monitor where the cursor currently is (uses virtual monitors for PBP)
    VirtualMonitorGetWorkArea(MonitorFromPoint(cursorX, cursorY), &monitorLeft, &monitorTop, &monitorRight, &monitorBottom)
    
    ; Calculate position under cursor, but keep it on screen
    guiX := cursorX - 10  ; Offset slightly so it's not directly under the cursor
    guiY := cursorY + 10
    
    ; Adjust if off the screen
    if (guiX + guiWidth > monitorRight)
        guiX := monitorRight - guiWidth
    if (guiY + guiHeight > monitorBottom)
        guiY := cursorY - guiHeight - 10  ; Show above cursor if not enough space below
    
    ; Show the GUI
    positioningGui.Show(Format("x{1} y{2} w{3} h{4}", guiX, guiY, guiWidth, guiHeight))
    
    ; Store the window handle for potential use in button clicks
    positioningGui.mwin := mwin
    
    return positioningGui
}

ListWindowPositions()

; Main function to list window positions
ListWindowPositions() {
    ; Create GUI (+ToolWindow to exclude from window lists)
    posViewer := Gui("+ToolWindow", "Window Position Viewer")
    posViewer.SetFont("s10", "Segoe UI")
    posViewer.Add("Text", "w800", "Active Windows and Their Positions:")

    ; Create ListView
    lv := posViewer.Add("ListView", "w800 h600 Grid", ["Window Title", "Process", "Left", "Top", "Right", "Bottom", "Width", "Height", "Class"])

    ; Add Refresh button
    btnRefresh := posViewer.Add("Button", "w120 h30", "Refresh")
    btnRefresh.OnEvent("Click", RefreshList)

    ; Add New Window button
    btnNew := posViewer.Add("Button", "w120 h30 x+10", "New Window")
    btnNew.OnEvent("Click", (*) => ListWindowPositions())

    ; Add Copy All button
    btnCopy := posViewer.Add("Button", "w120 h30 x+10", "Copy All")
    btnCopy.OnEvent("Click", CopyAll)

    ; Populate the list
    PopulateWindowList(lv)

    ; Show the GUI
    posViewer.Show()

    ; Function to refresh the window list
    RefreshList(*) {
        lv.Delete()
        PopulateWindowList(lv)
    }

    ; Function to copy all ListView content to clipboard
    CopyAll(*) {
        text := "Window Title`tProcess`tLeft`tTop`tRight`tBottom`tWidth`tHeight`tClass`n"
        rowCount := lv.GetCount()
        Loop rowCount {
            row := A_Index
            rowText := ""
            Loop 9 {
                rowText .= lv.GetText(row, A_Index) . "`t"
            }
            text .= RTrim(rowText, "`t") . "`n"
        }
        A_Clipboard := text
        ToolTip("Copied " rowCount " rows to clipboard")
        SetTimer(() => ToolTip(), -1500)
    }
}

; Function to populate the ListView with window data
PopulateWindowList(lv) {
    ; Save current state and disable hidden window detection
    prevDetectHidden := A_DetectHiddenWindows
    DetectHiddenWindows false

    ; Get all windows
    windowList := WinGetList()

    ; Get our own script's PID to exclude our windows
    scriptPID := ProcessExist()

    ; Loop through each window
    for hwnd in windowList {
        try {
            ; Skip our own script's windows
            if (WinGetPID("ahk_id " hwnd) == scriptPID)
                continue

            ; Skip if window isn't valid for our purposes
            if (!IsValidWindowForMove(hwnd))
                continue

            ; Skip windows that don't exist anymore
            if (!WinExist("ahk_id " hwnd))
                continue

            ; Get window information
            title := WinGetTitle("ahk_id " hwnd)
            process := WinGetProcessName("ahk_id " hwnd)
            class := WinGetClass("ahk_id " hwnd)

            ; Get position
            WinGetPos(&x, &y, &w, &h, "ahk_id " hwnd)

            ; Skip windows with invalid positions
            if (x == "" || y == "" || w == "" || h == "")
                continue

            ; Calculate right and bottom borders
            right := x + w
            bottom := y + h

            ; Add to ListView (empty title replaced with "[No Title]")
            title := title ? title : "[No Title]"
            lv.Add(, title, process, x, y, right, bottom, w, h, class)
        } catch {
            ; Skip this window if there's an error
            continue
        }
    }

    ; Restore previous state
    DetectHiddenWindows prevDetectHidden

    ; Auto-size columns
    Loop lv.GetCount("Column")
        lv.ModifyCol(A_Index, "AutoHdr")
}

IsValidWindowForMove(hwnd) { ; Check if the window is valid for moving
    if (!hwnd)
        return false

    ; Don't allow moving certain system windows
    windowClass := WinGetClass("ahk_id " hwnd)

    ; List of classes that shouldn't be moved
    excludedClasses := ["Progman", "WorkerW", "Shell_TrayWnd", "Windows.UI.Core.CoreWindow"]

    for class in excludedClasses {
        if (windowClass == class)
            return false
    }

    If (windowClass = "org.wezfurlong.wezterm")
        return true

    ; Get process info
    exeName := WinGetProcessName("ahk_id " hwnd)

    ; Explicitly check for Task Manager and other known elevated programs
    if (exeName = "Taskmgr.exe" || windowClass = "TaskManagerWindow" || exeName = "Razer Synapse Service Process.exe")
        return false

    If (exeName = "XYPlorer.exe" && windowClass == "ThunderRT6Main")
        return false

    ; List of specific executable names that are typically elevated
    elevatedExes := ["mmc.exe", "gpedit.msc", "regedit.exe", "secpol.msc", "services.msc"]
    for exe in elevatedExes {
        if (exeName = exe)
            return false
    }

    ; Check if the window has a shield icon (UAC shield) in its title bar
    title := WinGetTitle("ahk_id " hwnd)
    if (title ~= "i)(Administrator|Elevated|as Admin)")
        return false

    ; Check if the window is a system dialog
    if (WinGetStyle("ahk_id " hwnd) & 0x08000000) { ; WS_POPUP
        if (title ~= "i)^(Error|Warning|Info|Confirm|Prompt)")
            return false
    }

    ; Check if window can be moved (not minimized)
    minMax := WinGetMinMax("ahk_id " hwnd)
    if (minMax == -1) ; Window is minimized
        return false

    ; Try to detect elevated windows by checking if we can modify a window property
    try {
        ; Try to get a system menu - this will often fail for elevated windows when script isn't elevated
        hSysMenu := DllCall("GetSystemMenu", "Ptr", hwnd, "Int", false)
        if (!hSysMenu)
            return false

        ; Try to modify window style (but immediately restore it)
        currentStyle := WinGetStyle("ahk_id " hwnd)
        result := DllCall("SetWindowLong" (A_PtrSize=8?"Ptr":""), "Ptr", hwnd, "Int", -16, "Ptr", currentStyle)
        if (result = 0) ; This will fail for elevated windows when script is not elevated
            return false
    } catch {
        ; If any access is denied, assume it's an elevated window
        return false
    }

    return true
}
