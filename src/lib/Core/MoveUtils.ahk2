/** MonitorFromPoint
 * Determines which monitor contains a specified point (x,y) coordinate.
 * 
 * @param x The x-coordinate to check
 * @param y The y-coordinate to check
 * 
 * @returns {Integer} The monitor index that contains the point,
 *          or the primary monitor index if the point is not on any monitor
 */
MonitorFromPoint(x, y) {
    MonitorCount := MonitorGetCount()
    Loop MonitorCount {
        MonitorGet(A_Index, &MonLeft, &MonTop, &MonRight, &MonBottom)
        if (x >= MonLeft && x <= MonRight && y >= MonTop && y <= MonBottom)
            return A_Index
    }
    return MonitorGetPrimary()  ; Default to primary monitor if not found
}

/**
 * IsValidWindowForMove
 * Checks if a window can be moved by the window management script.
 * Prevents modification of system windows, dialogs, minimized windows,
 * and windows running with administrative privileges.
 * 
 * @param hwnd The window handle to check
 * 
 * @returns {Boolean} True if the window can be moved, false otherwise
 * 
 * @example
 * if (IsValidWindowForMove(WinExist("A")))
 *     MsgBox "This window can be moved!"
 */
; IsValidWindowForMove(hwnd) { ; Check if the window is valid for moving
;     if (!hwnd)
;         return false
        
;     ; Don't allow moving certain system windows
;     windowClass := WinGetClass("ahk_id " hwnd)
    
;     ; List of classes that shouldn't be moved
;     excludedClasses := ["Progman", "WorkerW", "Shell_TrayWnd", "Windows.UI.Core.CoreWindow"]
    
;     for class in excludedClasses {
;         if (windowClass == class)
;             return false
;     }
    
;     ; Get process info
;     exeName := WinGetProcessName("ahk_id " hwnd)
    
;     ; Explicitly check for Task Manager and other known elevated programs
;     if (exeName = "Taskmgr.exe" || windowClass = "TaskManagerWindow")
;         return false
        
;     ; List of specific executable names that are typically elevated
;     elevatedExes := ["mmc.exe", "gpedit.msc", "regedit.exe", "secpol.msc", "services.msc"]
;     for exe in elevatedExes {
;         if (exeName = exe)
;             return false
;     }
    
;     ; Check if the window has a shield icon (UAC shield) in its title bar
;     ; This is a simple heuristic that many admin windows have
;     title := WinGetTitle("ahk_id " hwnd)
;     if (title ~= "i)(Administrator|Elevated|as Admin)")
;         return false
    
;     ; Check if the window is a system dialog
;     if (WinGetStyle("ahk_id " hwnd) & 0x08000000) { ; WS_POPUP
;         if (title ~= "i)^(Error|Warning|Info|Confirm|Prompt)")
;             return false
;     }
    
;     ; Check if window can be moved (not minimized)
;     minMax := WinGetMinMax("ahk_id " hwnd)
;     if (minMax == -1) ; Window is minimized
;         return false
    
;     ; Try to detect elevated windows by checking if we can modify a window property
;     ; This is a good heuristic for detecting admin windows
;     try {
;         ; Try to get a system menu - this will often fail for elevated windows when script isn't elevated
;         hSysMenu := DllCall("GetSystemMenu", "Ptr", hwnd, "Int", false)
;         if (!hSysMenu)
;             return false
        
;         ; Try to modify window style (but immediately restore it)
;         currentStyle := WinGetStyle("ahk_id " hwnd)
;         result := DllCall("SetWindowLong" (A_PtrSize=8?"Ptr":""), "Ptr", hwnd, "Int", -16, "Ptr", currentStyle)
;         if (result = 0) ; This will fail for elevated windows when script is not elevated
;             return false
;     } catch {
;         ; If any access is denied, assume it's an elevated window
;         return false
;     }
        
;     return true
; }

/** IsWindowChildOf
 * Determines if a window is a child or owned by another window.
 * 
 * @param {Ptr} childHwnd Handle of the potential child window
 * @param {Ptr} parentHwnd Handle of the potential parent window
 * 
 * @returns {Boolean} True if the child window is a direct child or owned by the parent window
 * 
 * @example
 * isChild := IsWindowChildOf(childWindow, parentWindow)
 */
IsWindowChildOf(childHwnd, parentHwnd) {
    try {
        parentWindow := DllCall("GetParent", "Ptr", childHwnd, "Ptr")
        if (parentWindow && parentWindow == parentHwnd)
            return true
            
        ; Also check for owner relationship
        ownerWindow := DllCall("GetWindow", "Ptr", childHwnd, "UInt", 4, "Ptr") ; GW_OWNER = 4
        if (ownerWindow && ownerWindow == parentHwnd)
            return true
    }
    catch {
        return false
    }
    return false
}

/** GetWindowEdges
 * Retrieves a list of edges from all visible windows, excluding certain system windows.
 * 
 * @param {Ptr} excludeHwnd Window handle to exclude from edge collection
 * 
 * @returns {Array} List of window edges with type, position, title, and handle
 * 
 * @example
 * windowEdges := GetWindowEdges(currentWindowHandle)
 */
GetWindowEdges(excludeHwnd) {
    edges := []
    
    ; Get all windows
    hwnd := WinGetList(,, "Program Manager")
    
    Loop hwnd.Length {
        current := hwnd[A_Index]
        
        ; Skip the window being moved
        if (current == excludeHwnd)
            continue
            
        ; Skip if window no longer exists
        if (!WinExist("ahk_id " current))
            continue
        
        ; Get more details about the window for better filtering
        try {
            ; Skip if minimized, invisible, or has zero size
            if (WinGetMinMax("ahk_id " current) == -1)
                continue
                
            ; Skip system windows and special windows
            windowClass := WinGetClass("ahk_id " current)
            windowTitle := WinGetTitle("ahk_id " current)
            windowStyle := WinGetStyle("ahk_id " current)
            windowExStyle := WinGetExStyle("ahk_id " current)
            
            ; Skip windows that are likely not relevant for snapping
            if (windowClass ~= "i)^(Progman|WorkerW|Shell_TrayWnd|Windows\.UI\.Core\.CoreWindow|DV2ControlHost|BaseBar|NotifyIconOverflowWindow)$")
                continue
                
            ; Skip windows with certain attributes
            if (!(windowStyle & 0x10000000)) ; WS_VISIBLE
                continue
                
            if (windowExStyle & 0x00000080) ; WS_EX_TOOLWINDOW (skip tool windows)
                continue
                
            ; Skip windows with empty titles (likely system windows)
            if (windowTitle == "")
                continue
                
            ; Get window position
            WinGetPos &wx, &wy, &ww, &wh, "ahk_id " current
            if (ww < 50 || wh < 50)  ; Skip tiny windows (likely not main app windows)
                continue
                
            ; Add window edges with title for feedback
            title := windowTitle ? windowTitle : "Window"
                
            ; Create edge objects with window handle included
            edges.Push({type: "left", position: wx, title: title, hwnd: current})
            edges.Push({type: "right", position: wx + ww, title: title, hwnd: current})
            edges.Push({type: "top", position: wy, title: title, hwnd: current})
            edges.Push({type: "bottom", position: wy + wh, title: title, hwnd: current})
        }
        catch {
            ; Skip this window if any error occurs while getting its properties
            continue
        }
    }
    
    return edges
}

/** ProcessWindowSnapping
 * Calculates window snapping based on proximity to other window edges,
 * but only when windows have overlapping regions.
 * 
 * @param {Integer} x X-coordinate of the window
 * @param {Integer} y Y-coordinate of the window
 * @param {Integer} width Width of the window
 * @param {Integer} height Height of the window
 * @param {Array} edges List of window edges to snap against
 * 
 * @returns {Object} Snapping result with updated coordinates and snapping status
 */
ProcessWindowSnapping(x, y, width, height, edges) {
    result := {snapped: false, x: x, y: y, message: ""}
    
    ; Group edges by their parent window
    windowEdges := Map()
    for edge in edges {
        if !windowEdges.Has(edge.hwnd)
            windowEdges[edge.hwnd] := {title: edge.title, edges: []}
        
        windowEdges[edge.hwnd].edges.Push(edge)
    }
    
    ; Check each window for possible snapping
    for hwnd, window in windowEdges {
        ; Extract window dimensions from its edges
        targetWindow := {left: 0, right: 0, top: 0, bottom: 0}
        
        for edge in window.edges {
            if (edge.type == "left")
                targetWindow.left := edge.position
            else if (edge.type == "right")
                targetWindow.right := edge.position
            else if (edge.type == "top")
                targetWindow.top := edge.position
            else if (edge.type == "bottom")
                targetWindow.bottom := edge.position
        }
        
        ; Current window dimensions
        currentWindow := {
            left: x,
            right: x + width,
            top: y,
            bottom: y + height
        }
        
        ; Check for horizontal overlap (for vertical snapping)
        horizontalOverlap := !(currentWindow.right < targetWindow.left || currentWindow.left > targetWindow.right)
        
        ; Check for vertical overlap (for horizontal snapping)
        verticalOverlap := !(currentWindow.bottom < targetWindow.top || currentWindow.top > targetWindow.bottom)
        
        ; Check edges for snapping, but only if there's appropriate overlap
        for edge in window.edges {
            ; For horizontal edges (top/bottom), require horizontal overlap
            if ((edge.type == "top" || edge.type == "bottom") && horizontalOverlap) {
                ; Check top edge of current window to this edge
                if (Abs(y - edge.position) < snapDistance) {
                    result.y := edge.position
                    result.snapped := true
                    result.message := result.message ? result.message ", Top" : "Top to " window.title " " edge.type
                    break
                }
                
                ; Check bottom edge of current window to this edge
                if (Abs(y + height - edge.position) < snapDistance) {
                    result.y := edge.position - height
                    result.snapped := true
                    result.message := result.message ? result.message ", Bottom" : "Bottom to " window.title " " edge.type
                    break
                }
            }
            
            ; For vertical edges (left/right), require vertical overlap
            if ((edge.type == "left" || edge.type == "right") && verticalOverlap) {
                ; Check left edge of current window to this edge
                if (Abs(x - edge.position) < snapDistance) {
                    result.x := edge.position
                    result.snapped := true
                    result.message := "Left to " window.title " " edge.type
                    break
                }
                
                ; Check right edge of current window to this edge
                if (Abs(x + width - edge.position) < snapDistance) {
                    result.x := edge.position - width
                    result.snapped := true
                    result.message := "Right to " window.title " " edge.type
                    break
                }
            }
        }
        
        ; If we've snapped, no need to check other windows
        if (result.snapped)
            break
    }
    
    return result
}

ProcessWindowSnappingForResize(newX, y, newW, height, edges, snapDistance, isNearLeftEdge, isNearRightEdge) {
    result := {snapped: false, x: newX, width: newW}

    ; If neither edge is being actively resized, just return
    if (!isNearLeftEdge && !isNearRightEdge)
        return result

    currentLeft := newX
    currentRight := newX + newW

    ; Group edges by parent window
    windowEdges := Map()
    for edge in edges {
        if !windowEdges.Has(edge.hwnd)
            windowEdges[edge.hwnd] := {title: edge.title, edges: []}
        
        windowEdges[edge.hwnd].edges.Push(edge)
    }

    for hwnd, window in windowEdges {
        ; Determine the bounding box of this other window from its edges
        targetWindow := {left: 0, right: 0, top: 0, bottom: 0}
        for edge in window.edges {
            if (edge.type == "left")
                targetWindow.left := edge.position
            else if (edge.type == "right")
                targetWindow.right := edge.position
            else if (edge.type == "top")
                targetWindow.top := edge.position
            else if (edge.type == "bottom")
                targetWindow.bottom := edge.position
        }
        
        ; Find overlap in vertical dimension so we only snap if the windows
        ; have some overlapping region vertically
        thisTop    := y
        thisBottom := y + height
        thatTop    := targetWindow.top
        thatBottom := targetWindow.bottom
        
        verticalOverlap := !(thisBottom < thatTop || thisTop > thatBottom)
        if (!verticalOverlap)
            continue
        
        ; Now check horizontal edges for snapping
        for edge in window.edges {
            if (edge.type == "left" || edge.type == "right") {
                ; The other window's edge position
                targetPos := edge.position
                
                ; Snap left edge if we are resizing from the left
                if (isNearLeftEdge) {
                    ; If our new left edge is within snapDistance of targetPos
                    if (Abs(currentLeft - targetPos) < snapDistance) {
                        result.x := targetPos
                        result.width := currentRight - targetPos  ; keep right the same
                        result.snapped := true
                        return result
                    }
                }
                
                ; Snap right edge if we are resizing from the right
                if (isNearRightEdge) {
                    ; If our new right edge is within snapDistance of targetPos
                    if (Abs(currentRight - targetPos) < snapDistance) {
                        ; new width = targetPos - left
                        result.width := targetPos - currentLeft
                        result.snapped := true
                        return result
                    }
                }
            }
        }
    }

    return result
}

/** ProcessScreenSnapping
 * Calculates window snapping based on proximity to screen edges.
 * 
 * @param {Integer} x X-coordinate of the window
 * @param {Integer} y Y-coordinate of the window
 * @param {Integer} width Width of the window
 * @param {Integer} height Height of the window
 * @param {Integer} left Left boundary of the screen
 * @param {Integer} top Top boundary of the screen
 * @param {Integer} right Right boundary of the screen
 * @param {Integer} bottom Bottom boundary of the screen
 * 
 * @returns {Object} Snapping result with updated coordinates and snapping status
 * 
 * @example
 * screenSnapResult := ProcessScreenSnapping(windowX, windowY, windowWidth, windowHeight, monitorLeft, monitorTop, monitorRight, monitorBottom)
 */
ProcessScreenSnapping(x, y, width, height, left, top, right, bottom) {
    result := {snapped: false, x: x, y: y, message: ""}
    
    ; Left edge snapping
    if (Abs(x - left) < snapDistance) {
        result.x := left
        result.snapped := true
        result.message := "Screen Left"
    }
    
    ; Right edge snapping
    if (Abs(x + width - right) < snapDistance) {
        result.x := right - width
        result.snapped := true
        result.message := "Screen Right"
    }
    
    ; Top edge snapping
    if (Abs(y - top) < snapDistance) {
        result.y := top
        result.snapped := true
        result.message := result.message ? result.message ", Top" : "Screen Top"
    }
    
    ; Bottom edge snapping
    if (Abs(y + height - bottom) < snapDistance) {
        result.y := bottom - height
        result.snapped := true
        result.message := result.message ? result.message ", Bottom" : "Screen Bottom"
    }
    
    ; ; Center horizontally
    ; centerX := left + (right - left) / 2 - width / 2
    ; if (Abs(x - centerX) < snapDistance) {
    ;     result.x := Round(centerX)
    ;     result.snapped := true
    ;     result.message := result.message ? result.message ", Center H" : "Screen Center H"
    ; }
    
    ; ; Center vertically
    ; centerY := top + (bottom - top) / 2 - height / 2
    ; if (Abs(y - centerY) < snapDistance) {
    ;     result.y := Round(centerY)
    ;     result.snapped := true
    ;     result.message := result.message ? result.message ", Center V" : "Screen Center V"
    ; }
    
    return result
}

/** FindSnappedWindows
 * Identifies windows that are closely aligned with the main window.
 * 
 * @param {Ptr} mainWinHwnd Handle of the main window
 * @param {Integer} mainX X-coordinate of the main window
 * @param {Integer} mainY Y-coordinate of the main window
 * @param {Integer} mainWidth Width of the main window
 * @param {Integer} mainHeight Height of the main window
 * @param {Array} allWindowEdges List of all window edges
 * 
 * @returns {Array} List of window handles that are snapped to the main window
 * 
 * @example
 * snappedWindows := FindSnappedWindows(activeWindowHandle, windowX, windowY, windowWidth, windowHeight, windowEdges)
 */
FindSnappedWindows(mainWinHwnd, mainX, mainY, mainWidth, mainHeight, allWindowEdges) {
    snappedWindows := []
    snapTolerance := 5  ; How close windows need to be to be considered "snapped" (in pixels)
    
    ; Define the edges of our main window
    mainLeft := mainX
    mainRight := mainX + mainWidth
    mainTop := mainY
    mainBottom := mainY + mainHeight
    
    ; Find windows with edges that align with our main window
    processedWindows := Map()  ; Track windows we've already added
    
    ; Group edges by window handle for easier checking
    windowEdgesByHwnd := Map()
    
    for edge in allWindowEdges {
        if (!windowEdgesByHwnd.Has(edge.hwnd))
            windowEdgesByHwnd[edge.hwnd] := []
        
        windowEdgesByHwnd[edge.hwnd].Push(edge)
    }
    
    ; Check each window's edges against our main window
    for hwnd, edges in windowEdgesByHwnd {
        ; Skip our main window and already processed windows
        if (hwnd == mainWinHwnd || processedWindows.Has(hwnd))
            continue
        
        isSnapped := false
        
        ; Get this window's coordinates
        WinGetPos &wx, &wy, &ww, &wh, "ahk_id " hwnd
        otherLeft := wx
        otherRight := wx + ww
        otherTop := wy
        otherBottom := wy + wh
        
        ; Check horizontal alignment
        if (Abs(mainRight - otherLeft) <= snapTolerance || 
            Abs(mainLeft - otherRight) <= snapTolerance || 
            Abs(mainLeft - otherLeft) <= snapTolerance || 
            Abs(mainRight - otherRight) <= snapTolerance) {
            ; Check if there's vertical overlap
            if ((mainTop <= otherBottom && mainBottom >= otherTop) ||
                Abs(mainBottom - otherTop) <= snapTolerance || 
                Abs(mainTop - otherBottom) <= snapTolerance) {
                isSnapped := true
            }
        }
        
        ; Check vertical alignment
        if (Abs(mainBottom - otherTop) <= snapTolerance ||
            Abs(mainTop - otherBottom) <= snapTolerance ||
            Abs(mainTop - otherTop) <= snapTolerance ||
            Abs(mainBottom - otherBottom) <= snapTolerance) {
            ; Check if there's horizontal overlap
            if ((mainLeft <= otherRight && mainRight >= otherLeft) ||
                Abs(mainRight - otherLeft) <= snapTolerance || 
                Abs(mainLeft - otherRight) <= snapTolerance) {
                isSnapped := true
            }
        }
        
        if (isSnapped) {
            snappedWindows.Push(hwnd)
            processedWindows[hwnd] := true
        }
    }
    
    return snappedWindows
}

/** FindWindowsSnappedToBorder
 * Identifies windows that are snapped to a specific border of the main window.
 * 
 * @param {String} mainBorder Which border of the main window to check ("top", "bottom", "left", "right")
 * @param {Ptr} mainWinHwnd Handle of the main window
 * @param {Integer} mainX X-coordinate of the main window
 * @param {Integer} mainY Y-coordinate of the main window
 * @param {Integer} mainWidth Width of the main window
 * @param {Integer} mainHeight Height of the main window
 * @param {Array} allWindowEdges List of all window edges
 * 
 * @returns {Array} Array of objects {hwnd, border} where each object represents a window snapped to the specified border
 * 
 * @example
 * snappedWindows := FindWindowsSnappedToBorder("top", activeWindowHandle, windowX, windowY, windowWidth, windowHeight, windowEdges)
 */
FindWindowsSnappedToBorder(mainBorder, mainWinHwnd, mainX, mainY, mainWidth, mainHeight, allWindowEdges) {
    snappedWindows := []
    snapTolerance := 20
    
    ; ; Debug the window count first
    ; windowCount := Map()
    ; for edge in allWindowEdges {
    ;     if (edge.hwnd != mainWinHwnd && !windowCount.Has(edge.hwnd)) {
    ;         windowCount[edge.hwnd] := true
    ;     }
    ; }
    ; ToolTip("Checking " . windowCount.Count . " windows")
    ; SetTimer () => ToolTip(), -2000
    
    ; Define main window edges
    mainLeft := mainX
    mainRight := mainX + mainWidth
    mainTop := mainY
    mainBottom := mainY + mainHeight
    
    ; Group edges by window handle
    windowEdgesByHwnd := Map()
    for edge in allWindowEdges {
        if (!windowEdgesByHwnd.Has(edge.hwnd))
            windowEdgesByHwnd[edge.hwnd] := []
        
        windowEdgesByHwnd[edge.hwnd].Push(edge)
    }
    
    ; Process each window
    for hwnd, edges in windowEdgesByHwnd {
        if (hwnd == mainWinHwnd)
            continue
        
        ; Check if window exists before accessing it
        if (!WinExist("ahk_id " hwnd))
            continue
            
        ; Use try/catch to handle any errors with WinGetPos
        try {
            WinGetPos &wx, &wy, &ww, &wh, "ahk_id " hwnd
            
            ; Skip if we got invalid position values
            if (wx == "" || wy == "" || ww == "" || wh == "")
                continue
                
            otherLeft := wx
            otherRight := wx + ww
            otherTop := wy
            otherBottom := wy + wh
        } catch {
            ; Skip this window if any error occurs
            continue
        }
        
        ; Determine if snapped based on the mainBorder
        isSnapped := false
        snappedBorder := ""
        
        ; Check horizontal alignment for left/right borders
        if (mainBorder == "left" || mainBorder == "right") {
            if (Abs(mainLeft - otherRight) <= snapTolerance && 
                mainTop <= otherBottom && mainBottom >= otherTop) {
                if (mainBorder == "left") {
                    isSnapped := true
                    snappedBorder := "right"
                }
            }
            else if (Abs(mainRight - otherLeft) <= snapTolerance && 
                     mainTop <= otherBottom && mainBottom >= otherTop) {
                if (mainBorder == "right") {
                    isSnapped := true
                    snappedBorder := "left"
                }
            }
        }
        
        ; Similar checks for top/bottom if needed
        
        if (isSnapped) {
            try {
                title := WinGetTitle("ahk_id " hwnd)
            } catch {
                title := "Unknown"
            }
            snappedWindows.Push({hwnd: hwnd, border: snappedBorder, title: title})
        }
    }
    
    ; ; Debug info about what we found
    ; foundMsg := "Found " . snappedWindows.Length . " windows snapped to " . mainBorder
    ; ToolTip(foundMsg)
    ; SetTimer () => ToolTip(), -3000
    
    return snappedWindows
}

/** Highlights windows that are snapped to the specified border
 * @param {Array} snappedWindows Array of windows to highlight
 * @param {String} mainBorder The border that windows are snapped to
 * @returns {Array} Array of GUI objects for later cleanup
 */
HighlightSnappedWindows(snappedWindows, mainBorder) {
    ; Create a list to store our GUI objects
    highlightGuis := []
    
    ; Define colors for different border types
    borderColors := Map(
        "left", "0000FF",   ; Blue for left borders
        "right", "FF0000",  ; Red for right borders
        "top", "00FF00",    ; Green for top borders
        "bottom", "FF00FF"  ; Purple for bottom borders
    )
    
    ; Loop through each snapped window
    for snappedWindow in snappedWindows {
        hwnd := snappedWindow.hwnd
        snappedBorder := snappedWindow.border
        title := snappedWindow.title
        
        ; Get window position and size
        WinGetPos &wx, &wy, &ww, &wh, "ahk_id " hwnd
        
        ; Create a GUI to overlay this window
        MyGui := Gui("+AlwaysOnTop -Caption +ToolWindow +E0x20")
        MyGui.BackColor := "Black"
        MyGui.Opt("+LastFound")
        
        ; Make it semi-transparent
        WinSetTransparent(180)
        
        ; Add a border using the appropriate color
        borderColor := borderColors.Has(snappedBorder) ? borderColors[snappedBorder] : "FFFF00"
        borderWidth := 4
        
        ; Create colored border
        MyGui.Add("Progress", "x0 y0 w" ww " h" borderWidth " Background" borderColor)          ; Top
        MyGui.Add("Progress", "x0 y0 w" borderWidth " h" wh " Background" borderColor)          ; Left
        MyGui.Add("Progress", "x" ww-borderWidth " y0 w" borderWidth " h" wh " Background" borderColor)  ; Right
        MyGui.Add("Progress", "x0 y" wh-borderWidth " w" ww " h" borderWidth " Background" borderColor)  ; Bottom
        
        ; Add text showing the window title and border type
        infoText := title . " (" . snappedBorder . " border)"
        textOptions := "c" borderColor " BackgroundTrans Center"
        MyGui.Add("Text", "x" borderWidth " y" borderWidth+5 " w" ww-2*borderWidth " h30 " textOptions, infoText)
        
        ; Position the GUI over the window
        MyGui.Show("x" wx " y" wy " w" ww " h" wh " NoActivate")
        
        ; Store the GUI for later cleanup
        highlightGuis.Push(MyGui)
    }
    
    ; Create a summary GUI that shows the total count
    if (snappedWindows.Length > 0) {
        countGui := Gui("+AlwaysOnTop -Caption +ToolWindow")
        countGui.BackColor := "Black"
        countGui.SetFont("s14 cWhite", "Arial")
        countGui.Add("Text", "x10 y10", "Found " . snappedWindows.Length . " window(s) snapped to " . mainBorder . " edge")
        
        ; Position at bottom of screen
        MonitorGetWorkArea(, &mX, &mY, &mW, &mH)
        countGui.Show("x" mX+10 " y" mH-60 " w400 h50 NoActivate")
        
        highlightGuis.Push(countGui)
    }
    
    ; Set a timer to remove the highlights after 5 seconds
    SetTimer(DestroyHighlights.Bind(highlightGuis), -5000)
    
    return highlightGuis
}

/** Destroys the highlight GUIs
 * @param {Array} guis Array of GUI objects to destroy
 */
DestroyHighlights(guis) {
    for gui in guis {
        gui.Destroy()
    }
}

/** ShowWindowPositioningGUI
 * Displays a GUI with window positioning options.
 * 
 * @param {Ptr} mwin Handle of the window to be positioned
 * @param {Integer} cursorX X-coordinate of the cursor
 * @param {Integer} cursorY Y-coordinate of the cursor
 * 
 * @returns {Object} GUI object with positioning buttons
 * 
 * @example
 * positioningGui := ShowWindowPositioningGUI(activeWindow, cursorX, cursorY)
 */
ShowWindowPositioningGUI(mwin, cursorX, cursorY) {
    global positioningGui
    
    ; Create the GUI
    positioningGui := Gui("-Caption +AlwaysOnTop")
    
    ; Add buttons in the specified layout
    positioningGui.buttons := []
    
    ; Row 1: Left 50% | Right 50%
    positioningGui.buttons.Push(positioningGui.Add("Button", "w100 h30 x10 y10", "Left 50%").OnEvent("Click", ButtonClick))
    positioningGui.buttons.Push(positioningGui.Add("Button", "w100 h30 x+5", "Right 50%").OnEvent("Click", ButtonClick))
    
    ; Row 2: Left 25% | Middle 50% | Right 25%
    positioningGui.buttons.Push(positioningGui.Add("Button", "w65 h30 x10 y+5", "Left 25%").OnEvent("Click", ButtonClick))
    positioningGui.buttons.Push(positioningGui.Add("Button", "w65 h30 x+5", "Middle 50%").OnEvent("Click", ButtonClick))
    positioningGui.buttons.Push(positioningGui.Add("Button", "w65 h30 x+5", "Right 25%").OnEvent("Click", ButtonClick))
    
    ; Row 3: Left 33% | Middle 33% | Right 33%
    positioningGui.buttons.Push(positioningGui.Add("Button", "w65 h30 x10 y+5", "Left 33%").OnEvent("Click", ButtonClick))
    positioningGui.buttons.Push(positioningGui.Add("Button", "w65 h30 x+5", "Middle 33%").OnEvent("Click", ButtonClick))
    positioningGui.buttons.Push(positioningGui.Add("Button", "w65 h30 x+5", "Right 33%").OnEvent("Click", ButtonClick))
    
    ; Calculate GUI size
    guiWidth := 215  ; Width for buttons plus margins
    guiHeight := 115  ; Height for three rows of buttons plus margins
    
    ; Get the monitor where the cursor currently is
    MonitorGetWorkArea(MonitorFromPoint(cursorX, cursorY), &monitorLeft, &monitorTop, &monitorRight, &monitorBottom)
    
    ; Calculate position under cursor, but keep it on screen
    guiX := cursorX - 10  ; Offset slightly so it's not directly under the cursor
    guiY := cursorY + 10
    
    ; Adjust if off the screen
    if (guiX + guiWidth > monitorRight)
        guiX := monitorRight - guiWidth
    if (guiY + guiHeight > monitorBottom)
        guiY := cursorY - guiHeight - 10  ; Show above cursor if not enough space below
    
    ; Show the GUI
    positioningGui.Show(Format("x{1} y{2} w{3} h{4}", guiX, guiY, guiWidth, guiHeight))
    
    ; Store the window handle for potential use in button clicks
    positioningGui.mwin := mwin
    
    return positioningGui
}

ListWindowPositions()

; Main function to list window positions
ListWindowPositions() {
    ; Create GUI
    posViewer := Gui(, "Window Position Viewer")
    posViewer.SetFont("s10", "Segoe UI")
    posViewer.Add("Text", "w800", "Active Windows and Their Positions:")
    
    ; Create ListView
    lv := posViewer.Add("ListView", "w800 h600 Grid", ["Window Title", "Process", "Left", "Top", "Right", "Bottom", "Width", "Height", "Class"])
    
    ; Add Refresh button
    btnRefresh := posViewer.Add("Button", "w120 h30", "Refresh")
    btnRefresh.OnEvent("Click", RefreshList)
    
    ; Populate the list
    PopulateWindowList(lv)
    
    ; Show the GUI
    posViewer.Show()
    
    ; Function to refresh the window list
    RefreshList(*) {
        lv.Delete()
        PopulateWindowList(lv)
    }
}

; Function to populate the ListView with window data
PopulateWindowList(lv) {
    ; Get all windows
    windowList := WinGetList()
    
    ; Loop through each window
    for hwnd in windowList {
        ; Skip if window isn't valid for our purposes
        if (!IsValidWindowForMove(hwnd))
            continue
            
        ; Skip windows that don't exist anymore
        if (!WinExist("ahk_id " hwnd))
            continue
            
        ; Use try/catch to handle any errors
        try {
            ; Get window information
            title := WinGetTitle("ahk_id " hwnd)
            process := WinGetProcessName("ahk_id " hwnd)
            class := WinGetClass("ahk_id " hwnd)
            
            ; Get position
            WinGetPos(&x, &y, &w, &h, "ahk_id " hwnd)
            
            ; Skip windows with invalid positions
            if (x == "" || y == "" || w == "" || h == "")
                continue
                
            ; Calculate right and bottom borders
            right := x + w
            bottom := y + h
            
            ; Add to ListView (empty title replaced with "[No Title]")
            title := title ? title : "[No Title]"
            lv.Add(, title, process, x, y, right, bottom, w, h, class)
        } catch Error as e {
            ; Skip this window if there's an error
            continue
        }
    }
    
    ; Auto-size columns
    Loop lv.GetCount("Column")
        lv.ModifyCol(A_Index, "AutoHdr")
}

IsValidWindowForMove(hwnd) { ; Check if the window is valid for moving
    if (!hwnd)
        return false
        
    ; Don't allow moving certain system windows
    windowClass := WinGetClass("ahk_id " hwnd)
    
    ; List of classes that shouldn't be moved
    excludedClasses := ["Progman", "WorkerW", "Shell_TrayWnd", "Windows.UI.Core.CoreWindow"]
    
    for class in excludedClasses {
        if (windowClass == class)
            return false
    }
    
    If (windowClass = "org.wezfurlong.wezterm")
        return true
        
    ; Get process info
    exeName := WinGetProcessName("ahk_id " hwnd)
    
    ; Explicitly check for Task Manager and other known elevated programs
    if (exeName = "Taskmgr.exe" || windowClass = "TaskManagerWindow" || exeName = "Razer Synapse Service Process.exe")
        return false
        
    If (exeName = "XYPlorer.exe" && windowClass == "ThunderRT6Main")
        return false
        
        
    ; List of specific executable names that are typically elevated
    elevatedExes := ["mmc.exe", "gpedit.msc", "regedit.exe", "secpol.msc", "services.msc"]
    for exe in elevatedExes {
        if (exeName = exe)
            return false
    }
    
    ; Check if the window has a shield icon (UAC shield) in its title bar
    ; This is a simple heuristic that many admin windows have
    title := WinGetTitle("ahk_id " hwnd)
    if (title ~= "i)(Administrator|Elevated|as Admin)")
        return false
    
    ; Check if the window is a system dialog
    if (WinGetStyle("ahk_id " hwnd) & 0x08000000) { ; WS_POPUP
        if (title ~= "i)^(Error|Warning|Info|Confirm|Prompt)")
            return false
    }
    
    ; Check if window can be moved (not minimized)
    minMax := WinGetMinMax("ahk_id " hwnd)
    if (minMax == -1) ; Window is minimized
        return false
    
    ; Try to detect elevated windows by checking if we can modify a window property
    ; This is a good heuristic for detecting admin windows
    try {
        ; Try to get a system menu - this will often fail for elevated windows when script isn't elevated
        hSysMenu := DllCall("GetSystemMenu", "Ptr", hwnd, "Int", false)
        if (!hSysMenu)
            return false
        
        ; Try to modify window style (but immediately restore it)
        currentStyle := WinGetStyle("ahk_id " hwnd)
        result := DllCall("SetWindowLong" (A_PtrSize=8?"Ptr":""), "Ptr", hwnd, "Int", -16, "Ptr", currentStyle)
        if (result = 0) ; This will fail for elevated windows when script is not elevated
            return false
    } catch {
        ; If any access is denied, assume it's an elevated window
        return false
    }
        
    return true
}
