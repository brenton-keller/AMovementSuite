#Requires AutoHotkey v2.0
#SingleInstance Force

/** Colors
 * Static color and dimension constants for window scaling visualization.
 * 
 * @property {Object} BASELINE Base color for initial window state
 * @property {Object} TEAL Color representing maximum expansion
 * @property {Object} DEEP_PURPLE Color representing minimum size
 * @property {Integer} MIN_HEIGHT Minimum allowed window height
 * @property {Integer} MIN_WIDTH Minimum allowed window width
 */
class Colors {
    static BASELINE := {R: 34, G: 177, B: 76}     ;oklch(0.67 0.191 146.12)
    static TEAL := {R: 0, G: 150, B: 136}         ;oklch(0.6 0.1074 183.38)
    static DEEP_PURPLE := {R: 103, G: 58, B: 183} ;oklch(0.47 0.1862 294.78)
    static SOFT_MAGENTA := {R: 199, G: 78, B: 131}   ;complements baseline green rgb(199,78,131)
    static SOFT_CORAL := {R: 220, G: 120, B: 100}    ;complements teal
    static SOFT_OLIVE := {R: 180, G: 179, B: 87}     ;complements deep purple
    ; static BASELINE := {R: 0, G: 0, B: 0}    
    ; static TEAL := {R: 255, G: 0, B: 0}        
    ; static DEEP_PURPLE := {R: 0, G: 255, B: 0} 
    static MIN_HEIGHT := 100
    static MIN_WIDTH := 100
}

/** CalculateColorHeight
 * Calculates a color gradient based on window height progression.
 * Transitions from baseline color to teal when expanding, and baseline to deep purple when shrinking.
 * 
 * @param {Integer} currentHeight Current window height
 * @param {Integer} initialHeight Initial window height
 * @param {Integer} maxHeight Maximum possible window height
 * 
 * @returns {String} Hex color representing the current height state
 * 
 * @example
 * color := CalculateColorHeight(150, 100, 200)  ; Returns a color between baseline and teal
 */
CalculateColorHeight(currentHeight, initialHeight, maxHeight) {
    ; Safety check - prevent division by zero
    if (currentHeight >= initialHeight) {
        ; If maxHeight and initialHeight are the same, we're already at max
        if (maxHeight <= initialHeight) {
            ; Return the teal color since we're at max height
            return Format("{:02X}{:02X}{:02X}", Colors.TEAL.R, Colors.TEAL.G, Colors.TEAL.B)
        }
        
        percentage := (currentHeight - initialHeight) / (maxHeight - initialHeight)
        ; Clamp percentage to valid range
        percentage := Max(0, Min(1, percentage))
        r := Colors.BASELINE.R + (Colors.TEAL.R - Colors.BASELINE.R) * percentage
        g := Colors.BASELINE.G + (Colors.TEAL.G - Colors.BASELINE.G) * percentage
        b := Colors.BASELINE.B + (Colors.TEAL.B - Colors.BASELINE.B) * percentage
    }
    else {
        ; Add safety check for minimum height too
        if (initialHeight <= Colors.MIN_HEIGHT) {
            return Format("{:02X}{:02X}{:02X}", Colors.DEEP_PURPLE.R, Colors.DEEP_PURPLE.G, Colors.DEEP_PURPLE.B)
        }
        
        percentage := (initialHeight - currentHeight) / (initialHeight - Colors.MIN_HEIGHT)
        percentage := Min(1, percentage)
        r := Colors.BASELINE.R + (Colors.DEEP_PURPLE.R - Colors.BASELINE.R) * percentage
        g := Colors.BASELINE.G + (Colors.DEEP_PURPLE.G - Colors.BASELINE.G) * percentage
        b := Colors.BASELINE.B + (Colors.DEEP_PURPLE.B - Colors.BASELINE.B) * percentage
    }
    
    ; Clamp values between 0-255
    r := Round(Max(0, Min(255, r)))
    g := Round(Max(0, Min(255, g)))
    b := Round(Max(0, Min(255, b)))
    
    ; Return RGB color in hex format
    return Format("{:02X}{:02X}{:02X}", r, g, b)
}

/** CalculateColorWidth
 * Calculates a color gradient based on window width progression.
 * Transitions from baseline color to teal when expanding, and baseline to deep purple when shrinking.
 * 
 * @param {Integer} currentWidth Current window width
 * @param {Integer} initialWidth Initial window width
 * @param {Integer} maxWidth Maximum possible window width
 * @param {Integer} colorSet
 * 
 * @returns {String} Hex color representing the current width state
 * 
 * @example
 * color := CalculateColorWidth(200, 100, 300, 1)  ; Returns a color between baseline and teal
 */
CalculateColorWidth(currentWidth, initialWidth, maxWidth, colorSet) {
    if (colorSet == 1){
        color_base := Colors.BASELINE
        color_grow := Colors.TEAL
        color_shrink := Colors.DEEP_PURPLE
    } else if (colorSet == 2){
        color_base := Colors.SOFT_MAGENTA
        color_grow := Colors.SOFT_OLIVE
        color_shrink := Colors.SOFT_CORAL
        
    }
    if (currentWidth >= initialWidth) {
        color_change := color_grow
    } else {
        color_change := color_shrink
    }
    
    ; Safety check for division by zero
    if (maxWidth <= initialWidth) {
        return Format("{:02X}{:02X}{:02X}", color_change.R, color_change.G, color_change.B)
    }
    
    percentage := (currentWidth - initialWidth) / (maxWidth - initialWidth)
    percentage := Max(0, Min(1, percentage))
    
    ; Convert baseline and target colors to LCh
    baseLCh := RGBtoLCh(color_base.R, color_base.G, color_base.B)
    changeLCH := RGBtoLCh(color_change.R, color_change.G, color_change.B)
    
    ; Calculate shortest path hue delta
    hueDelta := Mod(changeLCH.h - baseLCh.h + 540, 360) - 180
    
    ; Interpolate in LCh space
    L := baseLCh.L + percentage * (changeLCH.L - baseLCh.L)
    C := baseLCh.C + percentage * (changeLCH.C - baseLCh.C)
    h := Mod(baseLCh.h + percentage * hueDelta, 360)
    
    ; Convert interpolated LCh color back to RGB
    rgb := LChtoRGB(L, C, h)
    
    ; Return RGB color in hex format
    return Format("{:02X}{:02X}{:02X}", rgb.R, rgb.G, rgb.B)
}

/** CalculateColorXY
 * Calculates a color gradient based on both window width and height progression.
 * Blends colors from both dimensions, giving more weight to larger changes.
 * 
 * @param {Integer} currentW Current window width
 * @param {Integer} currentH Current window height
 * @param {Integer} initialW Initial window width
 * @param {Integer} initialH Initial window height
 * @param {Integer} maxWidth Maximum possible window width
 * @param {Integer} maxHeight Maximum possible window height
 * 
 * @returns {String} Hex color representing the current window size state
 * 
 * @example
 * color := CalculateColorXY(200, 150, 100, 100, 300, 200)  ; Returns a blended color
 */
CalculateColorXY(currentW, currentH, initialW, initialH, maxWidth, maxHeight) {
    ; Calculate percentage changes for both dimensions
    if (currentW >= initialW) {
        ; Safety check for X-axis division by zero
        if (maxWidth <= initialW) {
            ; We're at max width, use full teal color for X
            rX := Colors.TEAL.R
            gX := Colors.TEAL.G
            bX := Colors.TEAL.B
            percentageW := 1
        } else {
            percentageW := (currentW - initialW) / (maxWidth - initialW)
            percentageW := Max(0, Min(1, percentageW))
            ; X-axis expansion color tends toward teal
            rX := Colors.BASELINE.R + (Colors.TEAL.R - Colors.BASELINE.R) * percentageW
            gX := Colors.BASELINE.G + (Colors.TEAL.G - Colors.BASELINE.G) * percentageW
            bX := Colors.BASELINE.B + (Colors.TEAL.B - Colors.BASELINE.B) * percentageW
        }
    } else {
        ; Safety check for minimum width
        if (initialW <= Colors.MIN_WIDTH) {
            rX := Colors.DEEP_PURPLE.R
            gX := Colors.DEEP_PURPLE.G
            bX := Colors.DEEP_PURPLE.B
            percentageW := 1
        } else {
            percentageW := (initialW - currentW) / (initialW - Colors.MIN_WIDTH)
            percentageW := Min(1, percentageW)
            ; X-axis shrinking color tends toward deep purple
            rX := Colors.BASELINE.R + (Colors.DEEP_PURPLE.R - Colors.BASELINE.R) * percentageW
            gX := Colors.BASELINE.G + (Colors.DEEP_PURPLE.G - Colors.BASELINE.G) * percentageW
            bX := Colors.BASELINE.B + (Colors.DEEP_PURPLE.B - Colors.BASELINE.B) * percentageW
        }
    }

    if (currentH >= initialH) {
        ; Safety check for Y-axis division by zero
        if (maxHeight <= initialH) {
            ; We're at max height, use full teal color for Y
            rY := Colors.TEAL.R
            gY := Colors.TEAL.G
            bY := Colors.TEAL.B
            percentageH := 1
        } else {
            percentageH := (currentH - initialH) / (maxHeight - initialH)
            percentageH := Max(0, Min(1, percentageH))
            ; Y-axis expansion color tends toward teal
            rY := Colors.BASELINE.R + (Colors.TEAL.R - Colors.BASELINE.R) * percentageH
            gY := Colors.BASELINE.G + (Colors.TEAL.G - Colors.BASELINE.G) * percentageH
            bY := Colors.BASELINE.B + (Colors.TEAL.B - Colors.BASELINE.B) * percentageH
        }
    } else {
        ; Safety check for minimum height
        if (initialH <= Colors.MIN_HEIGHT) {
            rY := Colors.DEEP_PURPLE.R
            gY := Colors.DEEP_PURPLE.G
            bY := Colors.DEEP_PURPLE.B
            percentageH := 1
        } else {
            percentageH := (initialH - currentH) / (initialH - Colors.MIN_HEIGHT)
            percentageH := Min(1, percentageH)
            ; Y-axis shrinking color tends toward deep purple
            rY := Colors.BASELINE.R + (Colors.DEEP_PURPLE.R - Colors.BASELINE.R) * percentageH
            gY := Colors.BASELINE.G + (Colors.DEEP_PURPLE.G - Colors.BASELINE.G) * percentageH
            bY := Colors.BASELINE.B + (Colors.DEEP_PURPLE.B - Colors.BASELINE.B) * percentageH
        }
    }

    ; Blend the colors from both axes
    ; Using a weighted average that gives more weight to larger changes
    weightX := Abs(currentW - initialW) / Max(1, initialW) ; Prevent division by zero
    weightY := Abs(currentH - initialH) / Max(1, initialH) ; Prevent division by zero
    totalWeight := weightX + weightY
    
    if (totalWeight = 0) {
        ; If no change, return baseline color
        r := Colors.BASELINE.R
        g := Colors.BASELINE.G
        b := Colors.BASELINE.B
    } else {
        ; Normalize weights
        weightX := weightX / totalWeight
        weightY := weightY / totalWeight
        
        ; Weighted blend of both axis colors
        r := (rX * weightX + rY * weightY)
        g := (gX * weightX + gY * weightY)
        b := (bX * weightX + bY * weightY)
    }

    ; Clamp values between 0-255
    r := Round(Max(0, Min(255, r)))
    g := Round(Max(0, Min(255, g)))
    b := Round(Max(0, Min(255, b)))

    ; Return RGB color in hex format
    return Format("{:02X}{:02X}{:02X}", r, g, b)
}

; ===== COLOR SPACE CONVERSION FUNCTIONS =====

; RGB to XYZ conversion
RGBtoXYZ(r, g, b) {
    ; Normalize RGB values to [0,1]
    r := r / 255, g := g / 255, b := b / 255
    
    ; Apply gamma correction
    r := (r <= 0.04045) ? (r / 12.92) : ((r + 0.055) / 1.055) ** 2.4
    g := (g <= 0.04045) ? (g / 12.92) : ((g + 0.055) / 1.055) ** 2.4
    b := (b <= 0.04045) ? (b / 12.92) : ((b + 0.055) / 1.055) ** 2.4
    
    ; Apply transformation matrix
    X := r * 0.4124 + g * 0.3576 + b * 0.1805
    Y := r * 0.2126 + g * 0.7152 + b * 0.0722
    Z := r * 0.0193 + g * 0.1192 + b * 0.9505
    
    return {X: X, Y: Y, Z: Z}
}

LabFunc(t) {
    return (t > 0.008856) ? t ** (1/3) : (7.787 * t + 16/116)
}

XYZtoLab(X, Y, Z) {
    ; D65 reference white
    Xn := 0.95047, Yn := 1.0, Zn := 1.08883
    
    ; Normalize XYZ
    X := X / Xn
    Y := Y / Yn
    Z := Z / Zn
    
    ; Apply transformation
    X := LabFunc(X)
    Y := LabFunc(Y)
    Z := LabFunc(Z)
    
    ; Calculate Lab
    L := 116 * Y - 16
    a := 500 * (X - Y)
    b := 200 * (Y - Z)
    
    return {L: L, a: a, b: b}
}

ATan2(y, x) {
    if (x > 0) {
        return ATan(y / x) * 180 / 3.14159265359
    } else if (x < 0 && y >= 0) {
        return ATan(y / x) * 180 / 3.14159265359 + 180
    } else if (x < 0 && y < 0) {
        return ATan(y / x) * 180 / 3.14159265359 - 180
    } else if (x = 0 && y > 0) {
        return 90
    } else if (x = 0 && y < 0) {
        return -90
    } else {
        return 0  ; x=0, y=0
    }
}

LabtoLCh(L, a, b) {
    C := Sqrt(a*a + b*b)
    
    ; Handle hue calculation correctly
    if (a = 0 && b = 0) {
        ; For grayscale colors, hue is undefined
        h := 0
    } else {
        ; Calculate hue in degrees
        h := ATan2(b, a)
        
        ; Ensure hue is in the range [0, 360)
        if (h < 0)
            h += 360
    }
    
    return {L: L, C: C, h: h}
}

LChtoLab(L, C, h) {
    ; Convert h from degrees to radians
    h := h * 3.14159265359 / 180
    
    a := C * Cos(h)
    b := C * Sin(h)
    
    return {L: L, a: a, b: b}
}

LabtoXYZ(L, a, b) {
    ; D65 reference white
    Xn := 0.95047, Yn := 1.0, Zn := 1.08883
    
    fy := (L + 16) / 116
    fx := a / 500 + fy
    fz := fy - b / 200
    
    ; Calculate XYZ
    X := Xn * ((fx**3 > 0.008856) ? fx**3 : (fx - 16/116) / 7.787)
    Y := Yn * ((fy**3 > 0.008856) ? fy**3 : (fy - 16/116) / 7.787)
    Z := Zn * ((fz**3 > 0.008856) ? fz**3 : (fz - 16/116) / 7.787)
    
    return {X: X, Y: Y, Z: Z}
}

XYZtoRGB(X, Y, Z) {
    ; Apply inverse transformation
    r := X * 3.2406 - Y * 1.5372 - Z * 0.4986
    g := -X * 0.9689 + Y * 1.8758 + Z * 0.0415
    b := X * 0.0557 - Y * 0.2040 + Z * 1.0570
    
    ; Apply inverse gamma correction
    r := (r <= 0.0031308) ? (12.92 * r) : (1.055 * r**(1/2.4) - 0.055)
    g := (g <= 0.0031308) ? (12.92 * g) : (1.055 * g**(1/2.4) - 0.055)
    b := (b <= 0.0031308) ? (12.92 * b) : (1.055 * b**(1/2.4) - 0.055)
    
    ; Clamp and scale to [0, 255]
    r := Round(Max(0, Min(1, r)) * 255)
    g := Round(Max(0, Min(1, g)) * 255)
    b := Round(Max(0, Min(1, b)) * 255)
    
    return {R: r, G: g, B: b}
}

RGBtoLCh(r, g, b) {
    xyz := RGBtoXYZ(r, g, b)
    lab := XYZtoLab(xyz.X, xyz.Y, xyz.Z)
    return LabtoLCh(lab.L, lab.a, lab.b)
}

LChtoRGB(L, C, h) {
    lab := LChtoLab(L, C, h)
    xyz := LabtoXYZ(lab.L, lab.a, lab.b)
    return XYZtoRGB(xyz.X, xyz.Y, xyz.Z)
}

InterpolateHue(h1, h2, t) {
    ; Handle the special case where either hue is undefined (achromatic colors)
    if (h1 = "" || h2 = "")
        return h1 ? h1 : h2
        
    ; Calculate the shortest path
    delta := Mod(h2 - h1 + 540, 360) - 180
    return Mod(h1 + t * delta, 360)
}

; ; Simple LCh Color Transition Debugger
; ShowColorTransition() {
;     ; Baseline to Teal
;     MsgBox("Testing Baseline to Teal transition")
    
;     ; Convert to LCh
;     startLCh := RGBtoLCh(Colors.BASELINE.R, Colors.BASELINE.G, Colors.BASELINE.B)
;     endLCh := RGBtoLCh(Colors.TEAL.R, Colors.TEAL.G, Colors.TEAL.B)
    
;     ; Calculate shortest path
;     hueDelta := Mod(endLCh.h - startLCh.h + 540, 360) - 180
    
;     MsgBox("Start LCh: " startLCh.L ", " startLCh.C ", " startLCh.h 
;          "`nEnd LCh: " endLCh.L ", " endLCh.C ", " endLCh.h
;          "`nHue delta: " hueDelta)
    
;     ; Show 10 steps
;     Loop 10 {
;         i := A_Index - 1
;         t := i / 10
        
;         L := startLCh.L + t * (endLCh.L - startLCh.L)
;         C := startLCh.C + t * (endLCh.C - startLCh.C)
;         h := Mod(startLCh.h + t * hueDelta, 360)
        
;         rgbResult := LChtoRGB(L, C, h)
        
;         MsgBox("Step at " i * 100 "% `nLCh: " L ", " C ", " h 
;               "`nRGB: " rgbResult.R ", " rgbResult.G ", " rgbResult.B)
;     }
; }

; ShowColorTransition()
