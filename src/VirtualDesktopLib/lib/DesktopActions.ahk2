; Main desktop action methods
static getCount() {
  return this._GetDesktops_Obj().GetCount()
}
static goToDesktopNum(desktopNum) {
  firstWindowId := this._getFirstWindowInVD(desktopNum)
  VD_animation_gui := Gui("-Border -SysMenu +Owner -Caption")
  VD_animation_gui_hwnd := VD_animation_gui.Hwnd + 0
  IVirtualDesktop := this._GetDesktops_Obj().GetAt(desktopNum)
  GUID_Desktop := Buffer(16)
  ptr_GetId := this._vtable(IVirtualDesktop, this.idx_GetId)
  DllCall(ptr_GetId, "Ptr", IVirtualDesktop, "Ptr", GUID_Desktop)
  DllCall(this.ptr_MoveWindowToDesktop, "Ptr", this.IVirtualDesktopManager.Ptr, "Ptr", VD_animation_gui_hwnd, "Ptr", GUID_Desktop)
  DllCall("ShowWindow", "Ptr", VD_animation_gui_hwnd, "Int", 4)
  this.SetForegroundWindow(VD_animation_gui_hwnd)
  loop 20 {
    if (this.getCurrentDesktopNum() == desktopNum) {
      if (firstWindowId) {
        DllCall("SetForegroundWindow", "Ptr", firstWindowId)
      } else {
        this._activateDesktopBackground()
      }
      break
    }
    Sleep 25
  }
  VD_animation_gui.Destroy()
}
static getCurrentDesktopNum() {
  IVirtualDesktop_ofCurrentDesktop := this._dll_GetCurrentDesktop()
  desktopNum := this._desktopNum_from_IVirtualDesktop(IVirtualDesktop_ofCurrentDesktop)
  return desktopNum
}
static createDesktop(goThere := false) {
  IVirtualDesktop_ofNewDesktop := this._dll_CreateDesktop()
  if (goThere) {
    desktopNum := this._desktopNum_from_IVirtualDesktop(IVirtualDesktop_ofNewDesktop)
    this.goToDesktopNum(desktopNum)
  }
}
static removeDesktop(desktopNum, fallback_desktopNum := false) {
  Desktops_Obj := this._GetDesktops_Obj()
  if (!fallback_desktopNum) {
    if (desktopNum > 1) {
      fallback_desktopNum := desktopNum - 1
    } else if (desktopNum < Desktops_Obj.GetCount()) {
      fallback_desktopNum := desktopNum + 1
    } else {
      return false
    }
  }
  IVirtualDesktop := Desktops_Obj.GetAt(desktopNum)
  IVirtualDesktop_fallback := Desktops_Obj.GetAt(fallback_desktopNum)
  this._dll_RemoveDesktop(IVirtualDesktop, IVirtualDesktop_fallback)
}
static createUntil(howMany, goToLastlyCreated := false) {
  howManyThereAlreadyAre := this.getCount()
  if (howManyThereAlreadyAre >= howMany) {
    return
  }
  loop howMany - howManyThereAlreadyAre - 1 {
    this.createDesktop(false)
  }
  this.createDesktop(goToLastlyCreated)
}
static goToDesktopByName(targetName) {
  desktopCount := this.getCount()
  
  ; Loop through all desktops to find one with the matching name
  Loop desktopCount {
    currentName := this.getNameFromDesktopNum(A_Index)
    if (currentName = targetName) {
      ; Found it! Switch to this desktop
      this.goToDesktopNum(A_Index)
      return A_Index
    }
  }
  
  ; Desktop with that name wasn't found
  return 0
}
static getRelativeDesktopNum(anchor_desktopNum, relative_count) {
  Desktops_Obj := this._GetDesktops_Obj()
  count_Desktops := Desktops_Obj.GetCount()
  absolute_desktopNum := anchor_desktopNum + relative_count
  absolute_desktopNum := Mod(absolute_desktopNum, count_Desktops)
  if (absolute_desktopNum <= 0) {
    absolute_desktopNum := absolute_desktopNum + count_Desktops
  }
  return absolute_desktopNum
}
static gotoRelativeDesktopNum(relative_count) {
  this.goToDesktopNum(this.getRelativeDesktopNum(this.getCurrentDesktopNum(), relative_count))
}
static goToLastActiveDesktop() {
  static lastDesktopNum := 0
  currentDesktopNum := this.getCurrentDesktopNum()

  ; Save current desktop before changing
  tempDesktopNum := lastDesktopNum
  lastDesktopNum := currentDesktopNum

  ; If a toggle pair is fully defined, use that
  if (this.isTogglePairDefined && this.toggleDesktop2 != 0) {
    ; If on desktop1, go to desktop2
    if (currentDesktopNum = this.toggleDesktop1) {
      this.goToDesktopNum(this.toggleDesktop2)
      return this.toggleDesktop2
    }
    ; If on desktop2, go to desktop1
    else if (currentDesktopNum = this.toggleDesktop2) {
      this.goToDesktopNum(this.toggleDesktop1)
      return this.toggleDesktop1
    }
    ; If on neither, go to desktop1
    else {
      this.goToDesktopNum(this.toggleDesktop1)
      return this.toggleDesktop1
    }
  }

  ; Fall back to original behavior if no toggle pair is defined
  if (tempDesktopNum > 0) {
    this.goToDesktopNum(tempDesktopNum)
    return tempDesktopNum
  }
  return 0
}

/**
 * Move a desktop to a specific position in the desktop order
 * @param sourceDesktopNum - Current position of desktop (1-based)
 * @param targetDesktopNum - Target position (1-based)
 * @returns {Boolean} - true on success, false on error
 */
static MoveDesktop(sourceDesktopNum, targetDesktopNum) {
  Desktops_Obj := this._GetDesktops_Obj()
  count_Desktops := Desktops_Obj.GetCount()

  ; Validate source index
  if (sourceDesktopNum < 1 || sourceDesktopNum > count_Desktops) {
    throw ValueError("Source desktop index out of range: " . sourceDesktopNum . " (valid: 1-" . count_Desktops . ")")
  }

  ; Validate target index
  if (targetDesktopNum < 1 || targetDesktopNum > count_Desktops) {
    throw ValueError("Target desktop index out of range: " . targetDesktopNum . " (valid: 1-" . count_Desktops . ")")
  }

  ; If already at target position, nothing to do
  if (sourceDesktopNum = targetDesktopNum)
    return true

  ; Get the desktop object to move
  IVirtualDesktop := Desktops_Obj.GetAt(sourceDesktopNum)

  ; Write debug info to log file
  logFile := A_ScriptDir . "\vd_movedesktop_debug.log"
  debugInfo := "=== MoveDesktop Debug Log ===`n"
  debugInfo .= "Timestamp: " . A_Now . "`n"
  debugInfo .= "Source Desktop: " . sourceDesktopNum . "`n"
  debugInfo .= "Target Desktop: " . targetDesktopNum . "`n"
  debugInfo .= "Total Desktops: " . count_Desktops . "`n"

  ; Get desktop names
  try {
    sourceName := this.getNameFromDesktopNum(sourceDesktopNum)
    targetName := this.getNameFromDesktopNum(targetDesktopNum)
    debugInfo .= "Source Desktop Name: '" . sourceName . "'`n"
    debugInfo .= "Target Desktop Name: '" . targetName . "'`n"
  } catch {
    debugInfo .= "Could not retrieve desktop names`n"
  }

  debugInfo .= "ptr_MoveDesktop: " . (this.ptr_MoveDesktop ? this.ptr_MoveDesktop : "NULL/UNDEFINED") . "`n"
  debugInfo .= "IVirtualDesktopManagerInternal.Ptr: " . this.IVirtualDesktopManagerInternal.Ptr . "`n"
  debugInfo .= "IVirtualDesktop: " . IVirtualDesktop . "`n"
  debugInfo .= "Target index (0-based): " . (targetDesktopNum - 1) . "`n"
  debugInfo .= "`nAttempting DllCall...`n"

  FileAppend(debugInfo, logFile)

  ; Call MoveDesktop COM method with error handling
  try {
    ; Parameters: this pointer, IVirtualDesktop*, HMONITOR, target index (0-based)
    ; Return value from DllCall IS the HRESULT
    result := DllCall(this.ptr_MoveDesktop,
      "Ptr", this.IVirtualDesktopManagerInternal.Ptr,  ; this pointer
      "Ptr", IVirtualDesktop,                           ; pDesktop to move
      "Ptr", 0,                                         ; hMonitor (0 for default)
      "Int", targetDesktopNum - 1)                      ; nIndex (0-based target position)

    ; Log result
    resultInfo := "DllCall completed`n"
    resultInfo .= "HRESULT: " . Format("0x{:08X}", result) . " (decimal: " . result . ")`n"
    resultInfo .= "Success: " . (result = 0 ? "YES" : "NO") . "`n"
    resultInfo .= "`n"
    FileAppend(resultInfo, logFile)
  } catch Error as err {
    ; DllCall itself threw an exception
    errorInfo := "DllCall THREW EXCEPTION!`n"
    errorInfo .= "Error Message: " . err.Message . "`n"
    errorInfo .= "Error What: " . err.What . "`n"
    errorInfo .= "Error Extra: " . err.Extra . "`n"
    errorInfo .= "`n"
    FileAppend(errorInfo, logFile)
    throw err
  }

  ; Show where log is
  ToolTip("Debug log written to:`n" . logFile)
  SetTimer(() => ToolTip(), -3000)

  ; Check for errors (S_OK = 0)
  if (result != 0) {
    throw Error("MoveDesktop COM call failed with HRESULT: " . Format("0x{:08X}", result))
  }

  return true
}

/**
 * Create a new desktop immediately after the current desktop and stay on current desktop
 * @returns {Object} - The newly created desktop object
 */
static CreateDesktopAfterCurrent() {
  ; Get current desktop number before creating new one
  currentNum := this.getCurrentDesktopNum()

  ; Create new desktop (will be created at the end)
  IVirtualDesktop_ofNewDesktop := this._dll_CreateDesktop()

  ; Small delay to ensure desktop is fully registered
  Sleep 50

  ; Get updated desktop count
  Desktops_Obj := this._GetDesktops_Obj()
  newDesktopIndex := Desktops_Obj.GetCount()

  ; Move the new desktop to position after current
  targetPosition := currentNum + 1
  this.MoveDesktop(newDesktopIndex, targetPosition)

  ; Small delay to ensure move is complete
  Sleep 50

  ; Stay on original desktop (it's still at the same position)
  this.goToDesktopNum(currentNum)

  return IVirtualDesktop_ofNewDesktop
}

; Define or update toggle pair of desktops
static defineTogglePair() {
  currentDesktop := this.getCurrentDesktopNum()
  
  ; If this is the first desktop in the pair or we're redefining
  if (!this.isTogglePairDefined || (this.isTogglePairDefined && this.toggleDesktop2 != 0)) {
    this.toggleDesktop1 := currentDesktop
    this.toggleDesktop2 := 0
    this.isTogglePairDefined := true
    return 1  ; First desktop set
  }
  
  ; If this is the second desktop in the pair
  if (currentDesktop != this.toggleDesktop1) {
    this.toggleDesktop2 := currentDesktop
    return 2  ; Second desktop set
  }
  
  return 0  ; Same desktop - invalid pair
}

; Clear the defined toggle pair
static clearTogglePair() {
  this.toggleDesktop1 := 0
  this.toggleDesktop2 := 0
  this.isTogglePairDefined := false
}
  
; Desktop toggle state variables
static toggleDesktop1 := 0
static toggleDesktop2 := 0
static isTogglePairDefined := false
