; Screenshot active window to user's Screenshots folder
; Uses GDI+ to capture and save as PNG

; Global variables for region selection
global regionSelectActive := false
global regionStartX := 0
global regionStartY := 0
global regionEndX := 0
global regionEndY := 0
global selectionGui := ""
global overlayGui := ""

PrintScreen:: {
    ; Get the active window
    hwnd := WinExist("A")
    if (!hwnd) {
        ShowScreenshotNotification("No active window", "", false)
        return
    }

    ; Get window position and size
    try {
        WinGetPos(&x, &y, &w, &h, "ahk_id " hwnd)
    } catch {
        ShowScreenshotNotification("Could not get window position", "", false)
        return
    }

    ; Build screenshot folder path
    screenshotDir := EnvGet("USERPROFILE") "\Screenshots"

    ; Create directory if it doesn't exist
    if (!DirExist(screenshotDir))
        DirCreate(screenshotDir)

    ; Generate filename: date_program_time
    datePart := FormatTime(, "yyyy-MM-dd")
    timePart := FormatTime(, "HHmmss")
    processName := WinGetProcessName("ahk_id " hwnd)
    processName := RegExReplace(processName, "\.exe$", "")  ; Remove .exe extension
    filename := screenshotDir "\" datePart "_" processName "_" timePart ".png"

    ; Initialize GDI+
    pToken := Gdip_Startup()
    if (!pToken) {
        ShowScreenshotNotification("Failed to initialize GDI+", "", false)
        return
    }

    ; Capture the window
    pBitmap := Gdip_BitmapFromHWND(hwnd)
    if (!pBitmap) {
        Gdip_Shutdown(pToken)
        ShowScreenshotNotification("Failed to capture window", "", false)
        return
    }

    ; Save as PNG
    result := Gdip_SaveBitmapToFile(pBitmap, filename)

    ; Cleanup
    Gdip_DisposeImage(pBitmap)
    Gdip_Shutdown(pToken)

    if (result == 0) {
        ; Copy file path to clipboard
        A_Clipboard := ":: " filename
        ShowScreenshotNotification("Screenshot saved & copied", filename, true)
    } else {
        ShowScreenshotNotification("Failed to save screenshot (error " result ")", "", false)
    }
}

+PrintScreen:: {
    ; Interactive region selection screenshot
    global regionSelectActive, regionStartX, regionStartY, regionEndX, regionEndY, selectionGui, overlayGui

    ; Set coordinate mode to screen for consistent positioning
    CoordMode("Mouse", "Screen")
    CoordMode("Pixel", "Screen")

    ; Create semi-transparent overlay covering all monitors
    overlayGui := Gui("+AlwaysOnTop -Caption +ToolWindow +E0x20 -DPIScale")
    overlayGui.BackColor := "000000"
    WinSetTransparent(80, overlayGui)

    ; Get virtual screen dimensions (all monitors)
    virtualScreenX := SysGet(76)  ; SM_XVIRTUALSCREEN
    virtualScreenY := SysGet(77)  ; SM_YVIRTUALSCREEN
    virtualScreenW := SysGet(78)  ; SM_CXVIRTUALSCREEN
    virtualScreenH := SysGet(79)  ; SM_CYVIRTUALSCREEN

    overlayGui.Show("x" virtualScreenX " y" virtualScreenY " w" virtualScreenW " h" virtualScreenH " NA")

    ; Create selection rectangle GUI (initially hidden)
    selectionGui := Gui("+AlwaysOnTop -Caption +ToolWindow +E0x20 -DPIScale")
    selectionGui.BackColor := "FF0000"
    WinSetTransparent(100, selectionGui)

    ; Show instruction tooltip
    ToolTip("Click and drag to select region`nPress ESC to cancel")

    ; Set up hotkeys for region selection
    Hotkey("LButton", StartRegionSelect, "On")
    Hotkey("Escape", CancelRegionSelect, "On")

    regionSelectActive := true

    ; Wait for selection to complete or cancel
    while (regionSelectActive) {
        Sleep(10)
    }

    ; Cleanup
    Hotkey("LButton", StartRegionSelect, "Off")
    Hotkey("Escape", CancelRegionSelect, "Off")
    ToolTip()

    if (overlayGui) {
        overlayGui.Destroy()
        overlayGui := ""
    }
    if (selectionGui) {
        selectionGui.Destroy()
        selectionGui := ""
    }

    ; If we have valid coordinates, capture the region
    if (regionStartX != 0 || regionStartY != 0 || regionEndX != 0 || regionEndY != 0) {
        CaptureRegion(regionStartX, regionStartY, regionEndX, regionEndY)

        ; Reset coordinates
        regionStartX := 0
        regionStartY := 0
        regionEndX := 0
        regionEndY := 0
    }
}

StartRegionSelect(*) {
    global regionStartX, regionStartY, regionEndX, regionEndY, selectionGui

    ; Get starting position
    MouseGetPos(&regionStartX, &regionStartY)
    regionEndX := regionStartX
    regionEndY := regionStartY

    ; Show selection rectangle
    selectionGui.Show("x" regionStartX " y" regionStartY " w1 h1 NA")

    ; Track mouse movement until button released
    Hotkey("LButton", StartRegionSelect, "Off")

    while GetKeyState("LButton", "P") {
        MouseGetPos(&regionEndX, &regionEndY)

        ; Calculate rectangle dimensions
        x := Min(regionStartX, regionEndX)
        y := Min(regionStartY, regionEndY)
        w := Abs(regionEndX - regionStartX)
        h := Abs(regionEndY - regionStartY)

        ; Update selection GUI
        selectionGui.Show("x" x " y" y " w" w " h" h " NA")

        Sleep(10)
    }

    ; Button released, finalize selection
    global regionSelectActive
    regionSelectActive := false
}

CancelRegionSelect(*) {
    global regionSelectActive, regionStartX, regionStartY, regionEndX, regionEndY

    ; Reset coordinates to indicate cancellation
    regionStartX := 0
    regionStartY := 0
    regionEndX := 0
    regionEndY := 0

    regionSelectActive := false
}

CaptureRegion(x1, y1, x2, y2) {
    ; Calculate region boundaries
    x := Min(x1, x2)
    y := Min(y1, y2)
    w := Abs(x2 - x1)
    h := Abs(y2 - y1)

    ; Ensure minimum size
    if (w < 5 || h < 5) {
        ShowScreenshotNotification("Region too small", "", false)
        return
    }

    ; Build screenshot folder path
    screenshotDir := EnvGet("USERPROFILE") "\Screenshots"

    ; Create directory if it doesn't exist
    if (!DirExist(screenshotDir))
        DirCreate(screenshotDir)

    ; Generate filename: date_region_time
    datePart := FormatTime(, "yyyy-MM-dd")
    timePart := FormatTime(, "HHmmss")
    filename := screenshotDir "\" datePart "_region_" timePart ".png"

    ; Initialize GDI+
    pToken := Gdip_Startup()
    if (!pToken) {
        ShowScreenshotNotification("Failed to initialize GDI+", "", false)
        return
    }

    ; Capture the screen region
    pBitmap := Gdip_BitmapFromScreen(x, y, w, h)
    if (!pBitmap) {
        Gdip_Shutdown(pToken)
        ShowScreenshotNotification("Failed to capture region", "", false)
        return
    }

    ; Save as PNG
    result := Gdip_SaveBitmapToFile(pBitmap, filename)

    ; Cleanup
    Gdip_DisposeImage(pBitmap)
    Gdip_Shutdown(pToken)

    if (result == 0) {
        ; Copy file path to clipboard with :: prefix
        A_Clipboard := ":: " filename
        ShowScreenshotNotification("Region captured & copied", filename, true)
    } else {
        ShowScreenshotNotification("Failed to save screenshot (error " result ")", "", false)
    }
}

; High-quality notification GUI for screenshot operations
ShowScreenshotNotification(message, filePath := "", isSuccess := true) {
    static notifGui := ""
    static textCtrl := ""
    static dismissTimer := ""

    ; Destroy previous notification if it exists
    if (notifGui) {
        try notifGui.Destroy()
        notifGui := ""
        textCtrl := ""
    }

    ; Create notification GUI
    notifGui := Gui("+ToolWindow -Caption +AlwaysOnTop +E0x20")
    notifGui.BackColor := "1a1a1a"
    notifGui.SetFont("s14 cWhite Bold", "Segoe UI")

    ; Build notification text
    prefix := isSuccess ? "SCREENSHOT: " : "ERROR: "
    notifText := prefix message
    if (filePath) {
        notifText .= "`n`n" filePath
    }

    ; Add text control
    textCtrl := notifGui.Add("Text", "x20 y15 w560 cWhite Center", notifText)

    ; Calculate height based on content
    guiHeight := filePath ? 120 : 60

    ; Position at center of screen
    notifGui.Show("x" (A_ScreenWidth/2 - 300) " y" (A_ScreenHeight/2 - guiHeight/2) " w600 h" guiHeight " NoActivate")
    WinSetTransparent 230, notifGui.Hwnd

    ; Clear existing timer if any
    if (dismissTimer) {
        SetTimer dismissTimer, 0
    }

    ; Set new auto-dismiss timer
    dismissTimer := () => (notifGui ? (notifGui.Destroy(), notifGui := "", textCtrl := "") : "")
    SetTimer dismissTimer, -2000
}

; ========== GDI+ Functions ==========

Gdip_Startup() {
    pToken := 0
    si := Buffer(24, 0)  ; GdiplusStartupInput
    NumPut("UInt", 1, si, 0)  ; GdiplusVersion

    DllCall("LoadLibrary", "Str", "gdiplus")
    DllCall("gdiplus\GdiplusStartup", "Ptr*", &pToken, "Ptr", si, "Ptr", 0)
    return pToken
}

Gdip_Shutdown(pToken) {
    DllCall("gdiplus\GdiplusShutdown", "Ptr", pToken)
}

Gdip_BitmapFromHWND(hwnd) {
    ; Get client area dimensions
    rect := Buffer(16, 0)
    DllCall("GetClientRect", "Ptr", hwnd, "Ptr", rect)
    width := NumGet(rect, 8, "Int")
    height := NumGet(rect, 12, "Int")

    if (width <= 0 || height <= 0) {
        ; Fallback to window rect if client rect fails
        WinGetPos(&x, &y, &width, &height, "ahk_id " hwnd)
    }

    ; Create compatible DC and bitmap
    hdcSrc := DllCall("GetDC", "Ptr", hwnd, "Ptr")
    hdcDest := DllCall("CreateCompatibleDC", "Ptr", hdcSrc, "Ptr")
    hBitmap := DllCall("CreateCompatibleBitmap", "Ptr", hdcSrc, "Int", width, "Int", height, "Ptr")
    hOld := DllCall("SelectObject", "Ptr", hdcDest, "Ptr", hBitmap, "Ptr")

    ; Use PrintWindow for better capture (works with layered windows)
    ; PW_RENDERFULLCONTENT = 2 for better DWM window capture
    DllCall("PrintWindow", "Ptr", hwnd, "Ptr", hdcDest, "UInt", 2)

    ; Create GDI+ bitmap from HBITMAP
    pBitmap := 0
    DllCall("gdiplus\GdipCreateBitmapFromHBITMAP", "Ptr", hBitmap, "Ptr", 0, "Ptr*", &pBitmap)

    ; Cleanup GDI objects
    DllCall("SelectObject", "Ptr", hdcDest, "Ptr", hOld)
    DllCall("DeleteObject", "Ptr", hBitmap)
    DllCall("DeleteDC", "Ptr", hdcDest)
    DllCall("ReleaseDC", "Ptr", hwnd, "Ptr", hdcSrc)

    return pBitmap
}

Gdip_DisposeImage(pBitmap) {
    DllCall("gdiplus\GdipDisposeImage", "Ptr", pBitmap)
}

Gdip_BitmapFromScreen(x, y, w, h) {
    ; Capture a region of the screen
    ; Create compatible DCs
    hdcSrc := DllCall("GetDC", "Ptr", 0, "Ptr")  ; Get screen DC
    hdcDest := DllCall("CreateCompatibleDC", "Ptr", hdcSrc, "Ptr")
    hBitmap := DllCall("CreateCompatibleBitmap", "Ptr", hdcSrc, "Int", w, "Int", h, "Ptr")
    hOld := DllCall("SelectObject", "Ptr", hdcDest, "Ptr", hBitmap, "Ptr")

    ; Copy screen region to bitmap
    DllCall("BitBlt", "Ptr", hdcDest, "Int", 0, "Int", 0, "Int", w, "Int", h,
            "Ptr", hdcSrc, "Int", x, "Int", y, "UInt", 0x00CC0020)  ; SRCCOPY

    ; Create GDI+ bitmap from HBITMAP
    pBitmap := 0
    DllCall("gdiplus\GdipCreateBitmapFromHBITMAP", "Ptr", hBitmap, "Ptr", 0, "Ptr*", &pBitmap)

    ; Cleanup GDI objects
    DllCall("SelectObject", "Ptr", hdcDest, "Ptr", hOld)
    DllCall("DeleteObject", "Ptr", hBitmap)
    DllCall("DeleteDC", "Ptr", hdcDest)
    DllCall("ReleaseDC", "Ptr", 0, "Ptr", hdcSrc)

    return pBitmap
}

Gdip_SaveBitmapToFile(pBitmap, filename) {
    ; Get encoder CLSID for PNG
    ; PNG CLSID: {557CF406-1A04-11D3-9A73-0000F81EF32E}
    clsid := Buffer(16, 0)
    NumPut("UInt", 0x557CF406, clsid, 0)
    NumPut("UShort", 0x1A04, clsid, 4)
    NumPut("UShort", 0x11D3, clsid, 6)
    NumPut("UChar", 0x9A, clsid, 8)
    NumPut("UChar", 0x73, clsid, 9)
    NumPut("UChar", 0x00, clsid, 10)
    NumPut("UChar", 0x00, clsid, 11)
    NumPut("UChar", 0xF8, clsid, 12)
    NumPut("UChar", 0x1E, clsid, 13)
    NumPut("UChar", 0xF3, clsid, 14)
    NumPut("UChar", 0x2E, clsid, 15)

    return DllCall("gdiplus\GdipSaveImageToFile", "Ptr", pBitmap, "WStr", filename, "Ptr", clsid, "Ptr", 0)
}
