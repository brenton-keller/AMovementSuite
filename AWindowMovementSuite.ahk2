#Requires AutoHotkey v2.0
#SingleInstance Force
#WinActivateForce

; Setup
ListLines 0
KeyHistory 0
SetWinDelay -1
SetControlDelay -1
CoordMode "Mouse", "Screen"

; Load core utilities
#Include %A_ScriptDir%\src\lib\Config\GlobalConfig.ahk2
#Include %A_ScriptDir%\src\lib\Core\CoreUtils.ahk2
#Include %A_ScriptDir%\src\lib\Core\ColorUtils.ahk2
#Include %A_ScriptDir%\src\lib\Core\MoveUtils.ahk2
#Include %A_ScriptDir%\src\lib\Core\ToggleUtils.ahk2
#Include %A_ScriptDir%\src\lib\Core\VirtualMonitorManager.ahk2

#Include src\Features\WindowMove.ahk2
#Include src\Features\WindowScaleWidth.ahk2
#Include src\Features\WindowScaleHeight.ahk2
#Include src\Features\WindowScaleXY.ahk2
#Include src\Features\WindowAlwaysOnTop.ahk2
#Include src\Features\WindowRollUp.ahk2
#Include src\Features\WindowDimmer.ahk2
#Include src\Features\DisableWindowModifications.ahk2
#Include src\Features\WindowCascade.ahk2
#Include src\Features\WindowVirtualDesktop.ahk2
#Include src\Features\WindowGrouping.ahk2
#Include src\Features\Calculator.ahk2
#Include src\Features\TaskbarAutoHide.ahk2

; Load mouse hotkeys
#Include src\MouseHotkeys\setting_mouse.ahk2

; Load UI components
#Include src\UI\PBPSettingsGUI.ahk2

; Load PBP settings from file
LoadPBPSettings()

; Create the tray menu
A_TrayMenu.Delete  ; Clear default menu
A_TrayMenu.Add "Width Scaling (LCtrl+RButton)", ToggleWidthScaling
A_TrayMenu.Add "Height Scaling (LShift+RButton)", ToggleHeightScaling
A_TrayMenu.Add "XY Scaling (LCtrl+LShift+RButton)", ToggleXYScaling
A_TrayMenu.Add  ; Separator
A_TrayMenu.Add "Window Always On Top (LCtrl+MButton)", ToggleWindowAlwaysOnTop
A_TrayMenu.Add  ; Separator
A_TrayMenu.Add "Window Move (LAlt+RButton)", ToggleWindowMove
A_TrayMenu.Add "Window Cascade (RAlt+Up)", ToggleWindowCascade
A_TrayMenu.Add "Virtual Desktop (#!Left/Right)", ToggleVirtualDesktop
A_TrayMenu.Add "Window Grouping (LAlt+LWin+LButton)", ToggleWindowGrouping
A_TrayMenu.Add  ; Separator
A_TrayMenu.Add "Window Move Settings", ShowWindowMoveSettings
A_TrayMenu.Add "Program Paths Configuration", ShowProgramPathsConfig
A_TrayMenu.Add  ; Separator
A_TrayMenu.Add "PBP Virtual Monitor", TogglePBPFromTray
A_TrayMenu.Add "PBP Settings...", ShowPBPSettings
A_TrayMenu.Add  ; Separator
A_TrayMenu.Add "Exit", (*) => ExitApp()

; Initialize menu checks
A_TrayMenu.Check "Width Scaling (LCtrl+RButton)"
A_TrayMenu.Check "Height Scaling (LShift+RButton)"
A_TrayMenu.Check "XY Scaling (LCtrl+LShift+RButton)"
A_TrayMenu.Check "Window Always On Top (LCtrl+MButton)"
A_TrayMenu.Check "Window Move (LAlt+RButton)"
A_TrayMenu.Check "Window Cascade (RAlt+Up)"
A_TrayMenu.Check "Virtual Desktop (#!Left/Right)"
A_TrayMenu.Check "Window Grouping (LAlt+LWin+LButton)"

; --- START: Monitor Information Display on Startup ---
ShowMonitorInfo() {
    global pbpEnabled, pbpSplitX, pbpSplitPercent

    ; Physical Monitor Info
    monitorCount := MonitorGetCount()
    infoText := "=== PHYSICAL MONITORS ===`r`n"
    infoText .= "Detected " monitorCount " Physical Monitor(s):`r`n`r`n"
    primaryMon := MonitorGetPrimary()

    Loop monitorCount {
        thisMon := A_Index

        MonitorGet(thisMon, &Left, &Top, &Right, &Bottom)
        Width := Right - Left
        Height := Bottom - Top
        physWidth := Width  ; Store for virtual monitor calculations

        MonitorGetWorkArea(thisMon, &WorkLeft, &WorkTop, &WorkRight, &WorkBottom)
        WorkWidth := WorkRight - WorkLeft
        WorkHeight := WorkBottom - WorkTop

        isPrimary := (thisMon == primaryMon) ? "Yes" : "No"

        infoText .= "--- Physical Monitor " thisMon " ---`r`n"
        infoText .= "  Primary: " isPrimary " | Resolution: " Width "x" Height "`r`n"
        infoText .= "  Position: X=" Left ", Y=" Top "`r`n"
        infoText .= "  Work Area: " WorkWidth "x" WorkHeight "`r`n`r`n"
    }

    ; Virtual Monitor Info (if PBP is enabled)
    if (pbpEnabled) {
        virtualCount := VirtualMonitorGetCount()
        leftWidth := pbpSplitX
        rightWidth := physWidth - pbpSplitX
        infoText .= "`r`n=== VIRTUAL MONITORS (PBP ENABLED) ===`r`n"
        infoText .= "Split Configuration: " pbpSplitPercent "% (" leftWidth "px / " rightWidth "px)`r`n"
        infoText .= "Virtual Monitors: " virtualCount "`r`n`r`n"

        Loop virtualCount {
            thisMon := A_Index

            VirtualMonitorGet(thisMon, &Left, &Top, &Right, &Bottom)
            Width := Right - Left
            Height := Bottom - Top

            VirtualMonitorGetWorkArea(thisMon, &WorkLeft, &WorkTop, &WorkRight, &WorkBottom)
            WorkWidth := WorkRight - WorkLeft
            WorkHeight := WorkBottom - WorkTop

            isPrimary := (thisMon == GetVirtualMonitorPrimary()) ? "Yes" : "No"

            infoText .= "--- Virtual Monitor " thisMon " ---`r`n"
            infoText .= "  Primary: " isPrimary " | Resolution: " Width "x" Height "`r`n"
            infoText .= "  Position: X=" Left ", Y=" Top "`r`n"
            infoText .= "  Bounds: Left=" Left ", Right=" Right "`r`n`r`n"
        }
    } else {
        infoText .= "`r`n=== PBP MODE ===`r`n"
        infoText .= "Status: DISABLED`r`n"
        infoText .= "Toggle with: ScrollLock or Tray Menu`r`n`r`n"
    }

    ; --- Create a Custom GUI instead of MsgBox ---
    ; Estimate reasonable GUI size (adjust as needed)
    guiWidth := 550
    guiHeight := 300 + (monitorCount * 130) ; Base height + extra per monitor
    if guiHeight > A_ScreenHeight * 0.8 ; Limit max height
        guiHeight := Floor(A_ScreenHeight * 0.8)

    ; Create the GUI window
    InfoGui := Gui("+AlwaysOnTop +Resize", "Connected Monitor Information")
    InfoGui.SetFont("s10", "Consolas") ; Use a monospaced font for better alignment

    ; Add a ReadOnly Edit control to display the text
    ; R = Rows (approximate height), W = Width, ReadOnly makes it non-editable but selectable
    editCtrl := InfoGui.Add("Edit", "w" (guiWidth - 30) " R" (Floor(guiHeight/18)-3) " ReadOnly -VScroll", infoText)

    ; Add an OK button to close the GUI
    buttonYPos := guiHeight - 45
    buttonCtrl := InfoGui.Add("Button", "xm+" (guiWidth/2 - 50) " w100 Default", "OK")
    buttonCtrl.OnEvent("Click", InfoGui_Close)

    ; Function to close the GUI
    InfoGui_Close(*) {
        InfoGui.Destroy()
    }

    ; Handle GUI resize event (optional, but nice)
    InfoGui.OnEvent("Size", InfoGui_Size)
    InfoGui_Size(guiObj, MinMax, Width, Height) {
        ; Resize the Edit control when the GUI is resized
        if IsObject(editCtrl) {
             ; Adjust Edit control width and height relative to GUI size
             ; Leave some margin for borders and the button
            editCtrl.Move(15, 15, Width - 30, Height - 65)
        }
         ; Reposition the OK button
        if IsObject(buttonCtrl) {
            buttonCtrl.Move(Width/2 - 50, Height - 45)
        }
    }


    ; Show the GUI modally (script pauses until it's closed)
    InfoGui.Show("w" guiWidth " h" guiHeight) ; Show with calculated dimensions
}

ShowMonitorInfo() ; Call the function immediately on script start
; --- END: Monitor Information Display on Startup ---

; --- START: PBP Virtual Monitor Toggle ---
TogglePBPFromTray(*) {
    global pbpEnabled
    TogglePBPMode()  ; Call the function from VirtualMonitorManager

    ; Update tray menu check
    if (pbpEnabled) {
        A_TrayMenu.Check "PBP Virtual Monitor"
    } else {
        A_TrayMenu.Uncheck "PBP Virtual Monitor"
    }
}

; ScrollLock hotkey to toggle PBP mode
ScrollLock::{
    TogglePBPFromTray()
}
; --- END: PBP Virtual Monitor Toggle ---
