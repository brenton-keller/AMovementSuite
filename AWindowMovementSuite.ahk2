#Requires AutoHotkey v2.0
#SingleInstance Force
#WinActivateForce

; Setup
ListLines 0
KeyHistory 0
SetWinDelay -1
SetControlDelay -1
CoordMode "Mouse", "Screen"

; Load core utilities
#Include %A_ScriptDir%\src\lib\Config\GlobalConfig.ahk2
#Include %A_ScriptDir%\src\lib\Core\CoreUtils.ahk2
#Include %A_ScriptDir%\src\lib\Core\ColorUtils.ahk2
#Include %A_ScriptDir%\src\lib\Core\MoveUtils.ahk2
#Include %A_ScriptDir%\src\lib\Core\ToggleUtils.ahk2

#Include src\Features\WindowMove.ahk2
#Include src\Features\WindowScaleWidth.ahk2
#Include src\Features\WindowScaleHeight.ahk2
#Include src\Features\WindowScaleXY.ahk2
#Include src\Features\WindowAlwaysOnTop.ahk2
#Include src\Features\WindowRollUp.ahk2
#Include src\Features\WindowDimmer.ahk2
#Include src\Features\DisableWindowModifications.ahk2

; Create the tray menu
A_TrayMenu.Delete  ; Clear default menu
A_TrayMenu.Add "Width Scaling (LCtrl+RButton)", ToggleWidthScaling
A_TrayMenu.Add "Height Scaling (LShift+RButton)", ToggleHeightScaling
A_TrayMenu.Add "XY Scaling (LCtrl+LShift+RButton)", ToggleXYScaling
A_TrayMenu.Add  ; Separator
A_TrayMenu.Add "Window Always On Top (LCtrl+MButton)", ToggleWindowAlwaysOnTop
A_TrayMenu.Add  ; Separator
A_TrayMenu.Add "Window Move (LAlt+RButton)", ToggleWindowMove
A_TrayMenu.Add  ; Separator
A_TrayMenu.Add "Window Move Settings", ShowWindowMoveSettings
A_TrayMenu.Add  ; Separator
A_TrayMenu.Add "Exit", (*) => ExitApp()

; Initialize menu checks
A_TrayMenu.Check "Width Scaling (LCtrl+RButton)"
A_TrayMenu.Check "Height Scaling (LShift+RButton)"
A_TrayMenu.Check "XY Scaling (LCtrl+LShift+RButton)"
A_TrayMenu.Check "Window Always On Top (LCtrl+MButton)"
A_TrayMenu.Check "Window Move (LAlt+RButton)"

; --- START: Monitor Information Display on Startup ---
ShowMonitorInfo() {
    monitorCount := MonitorGetCount()
    infoText := "Detected " monitorCount " Monitor(s):`r`n`r`n" ; Use `r`n for Edit controls
    primaryMon := MonitorGetPrimary()

    Loop monitorCount {
        thisMon := A_Index ; Current monitor number in the loop

        ; Get full monitor coordinates and dimensions
        MonitorGet(thisMon, &Left, &Top, &Right, &Bottom)
        Width := Right - Left
        Height := Bottom - Top

        ; Get work area (excluding taskbar, usually) coordinates and dimensions
        MonitorGetWorkArea(thisMon, &WorkLeft, &WorkTop, &WorkRight, &WorkBottom)
        WorkWidth := WorkRight - WorkLeft
        WorkHeight := WorkBottom - WorkTop

        ; Check if this is the primary monitor
        isPrimary := (thisMon == primaryMon) ? "Yes" : "No"

        ; Build the text block for this monitor (use `r`n for newlines in Edit controls)
        infoText .= "--- Monitor " thisMon " ---`r`n"
        infoText .= "  Primary Monitor: " isPrimary "`r`n"
        infoText .= "  Position (Top-Left Corner): X=" Left ", Y=" Top "`r`n"
        infoText .= "  Full Resolution: " Width "x" Height "`r`n"
        infoText .= "  Bounding Box (Raw Coords): Left=" Left ", Top=" Top ", Right=" Right ", Bottom=" Bottom "`r`n"
        infoText .= "  Work Area Position (Top-Left): X=" WorkLeft ", Y=" WorkTop "`r`n"
        infoText .= "  Work Area Size: " WorkWidth "x" WorkHeight "`r`n"
        infoText .= "  Work Area Box (Raw Coords): Left=" WorkLeft ", Top=" WorkTop ", Right=" WorkRight ", Bottom=" WorkBottom "`r`n`r`n"
    }

    ; --- Create a Custom GUI instead of MsgBox ---
    ; Estimate reasonable GUI size (adjust as needed)
    guiWidth := 550
    guiHeight := 300 + (monitorCount * 130) ; Base height + extra per monitor
    if guiHeight > A_ScreenHeight * 0.8 ; Limit max height
        guiHeight := Floor(A_ScreenHeight * 0.8)

    ; Create the GUI window
    InfoGui := Gui("+AlwaysOnTop +Resize", "Connected Monitor Information")
    InfoGui.SetFont("s10", "Consolas") ; Use a monospaced font for better alignment

    ; Add a ReadOnly Edit control to display the text
    ; R = Rows (approximate height), W = Width, ReadOnly makes it non-editable but selectable
    editCtrl := InfoGui.Add("Edit", "w" (guiWidth - 30) " R" (Floor(guiHeight/18)-3) " ReadOnly -VScroll", infoText)

    ; Add an OK button to close the GUI
    buttonYPos := guiHeight - 45
    buttonCtrl := InfoGui.Add("Button", "xm+" (guiWidth/2 - 50) " w100 Default", "OK")
    buttonCtrl.OnEvent("Click", InfoGui_Close)

    ; Function to close the GUI
    InfoGui_Close(*) {
        InfoGui.Destroy()
    }

    ; Handle GUI resize event (optional, but nice)
    InfoGui.OnEvent("Size", InfoGui_Size)
    InfoGui_Size(guiObj, MinMax, Width, Height) {
        ; Resize the Edit control when the GUI is resized
        if IsObject(editCtrl) {
             ; Adjust Edit control width and height relative to GUI size
             ; Leave some margin for borders and the button
            editCtrl.Move(15, 15, Width - 30, Height - 65)
        }
         ; Reposition the OK button
        if IsObject(buttonCtrl) {
            buttonCtrl.Move(Width/2 - 50, Height - 45)
        }
    }


    ; Show the GUI modally (script pauses until it's closed)
    InfoGui.Show("w" guiWidth " h" guiHeight) ; Show with calculated dimensions
}

ShowMonitorInfo() ; Call the function immediately on script start
; --- END: Monitor Information Display on Startup ---
