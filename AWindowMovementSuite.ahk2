#Requires AutoHotkey v2.0
#SingleInstance Force
#WinActivateForce

; Setup
ListLines 0
KeyHistory 0
SetWinDelay -1
SetControlDelay -1
CoordMode "Mouse", "Screen"

; Load core utilities
#Include %A_ScriptDir%\src\lib\Config\GlobalConfig.ahk2
#Include %A_ScriptDir%\src\lib\Core\CoreUtils.ahk2
#Include %A_ScriptDir%\src\lib\Core\ColorUtils.ahk2
#Include %A_ScriptDir%\src\lib\Core\MoveUtils.ahk2
#Include %A_ScriptDir%\src\lib\Core\ToggleUtils.ahk2
#Include %A_ScriptDir%\src\lib\Core\VirtualMonitorManager.ahk2

#Include src\Features\WindowMove.ahk2
#Include src\Features\WindowScaleWidth.ahk2
#Include src\Features\WindowScaleHeight.ahk2
#Include src\Features\WindowScaleXY.ahk2
#Include src\Features\WindowAlwaysOnTop.ahk2
#Include src\Features\WindowRollUp.ahk2
#Include src\Features\WindowDimmer.ahk2
#Include src\Features\DisableWindowModifications.ahk2
#Include src\Features\WindowCascade.ahk2
#Include src\Features\WindowVirtualDesktop.ahk2
#Include src\Features\WindowGrouping.ahk2
#Include src\Features\Calculator.ahk2
#Include src\Features\TaskbarAutoHide.ahk2

; Load mouse hotkeys
#Include src\MouseHotkeys\setting_mouse.ahk2

; Load UI components
#Include src\UI\PBPSettingsGUI.ahk2

; Load PBP settings from file
LoadPBPSettings()

; Create the tray menu
A_TrayMenu.Delete  ; Clear default menu
A_TrayMenu.Add "Width Scaling (LCtrl+RButton)", ToggleWidthScaling
A_TrayMenu.Add "Height Scaling (LShift+RButton)", ToggleHeightScaling
A_TrayMenu.Add "XY Scaling (LCtrl+LShift+RButton)", ToggleXYScaling
A_TrayMenu.Add  ; Separator
A_TrayMenu.Add "Window Always On Top (LCtrl+MButton)", ToggleWindowAlwaysOnTop
A_TrayMenu.Add  ; Separator
A_TrayMenu.Add "Window Move (LAlt+RButton)", ToggleWindowMove
A_TrayMenu.Add "Window Cascade (RAlt+Up)", ToggleWindowCascade
A_TrayMenu.Add "Virtual Desktop (#!Left/Right)", ToggleVirtualDesktop
A_TrayMenu.Add "Window Grouping (LAlt+LWin+LButton)", ToggleWindowGrouping
A_TrayMenu.Add  ; Separator
A_TrayMenu.Add "Window Move Settings", ShowWindowMoveSettings
A_TrayMenu.Add "Program Paths Configuration", ShowProgramPathsConfig
A_TrayMenu.Add  ; Separator
A_TrayMenu.Add "PBP Virtual Monitor", TogglePBPFromTray
A_TrayMenu.Add "PBP Settings...", ShowPBPSettings
A_TrayMenu.Add  ; Separator
A_TrayMenu.Add "Exit", (*) => ExitApp()

; Initialize menu checks
A_TrayMenu.Check "Width Scaling (LCtrl+RButton)"
A_TrayMenu.Check "Height Scaling (LShift+RButton)"
A_TrayMenu.Check "XY Scaling (LCtrl+LShift+RButton)"
A_TrayMenu.Check "Window Always On Top (LCtrl+MButton)"
A_TrayMenu.Check "Window Move (LAlt+RButton)"
A_TrayMenu.Check "Window Cascade (RAlt+Up)"
A_TrayMenu.Check "Virtual Desktop (#!Left/Right)"
A_TrayMenu.Check "Window Grouping (LAlt+LWin+LButton)"

; --- START: Monitor Information Display on Startup ---
ShowMonitorInfo() {
    global pbpEnabled, pbpSplitX, pbpSplitPercent

    ; Physical Monitor Info
    monitorCount := MonitorGetCount()
    infoText := "=== PHYSICAL MONITORS ===`r`n"
    infoText .= "Detected " monitorCount " Physical Monitor(s):`r`n`r`n"
    primaryMon := MonitorGetPrimary()

    Loop monitorCount {
        thisMon := A_Index

        MonitorGet(thisMon, &Left, &Top, &Right, &Bottom)
        Width := Right - Left
        Height := Bottom - Top
        physWidth := Width  ; Store for virtual monitor calculations

        MonitorGetWorkArea(thisMon, &WorkLeft, &WorkTop, &WorkRight, &WorkBottom)
        WorkWidth := WorkRight - WorkLeft
        WorkHeight := WorkBottom - WorkTop

        isPrimary := (thisMon == primaryMon) ? "Yes" : "No"

        infoText .= "--- Physical Monitor " thisMon " ---`r`n"
        infoText .= "  Primary: " isPrimary " | Resolution: " Width "x" Height "`r`n"
        infoText .= "  Position: X=" Left ", Y=" Top "`r`n"
        infoText .= "  Work Area: " WorkWidth "x" WorkHeight "`r`n`r`n"
    }

    ; Virtual Monitor Info (if PBP is enabled)
    if (pbpEnabled) {
        virtualCount := VirtualMonitorGetCount()
        leftWidth := pbpSplitX
        rightWidth := physWidth - pbpSplitX
        infoText .= "`r`n=== VIRTUAL MONITORS (PBP ENABLED) ===`r`n"
        infoText .= "Split Configuration: " pbpSplitPercent "% (" leftWidth "px / " rightWidth "px)`r`n"
        infoText .= "Virtual Monitors: " virtualCount "`r`n`r`n"

        Loop virtualCount {
            thisMon := A_Index

            VirtualMonitorGet(thisMon, &Left, &Top, &Right, &Bottom)
            Width := Right - Left
            Height := Bottom - Top

            VirtualMonitorGetWorkArea(thisMon, &WorkLeft, &WorkTop, &WorkRight, &WorkBottom)
            WorkWidth := WorkRight - WorkLeft
            WorkHeight := WorkBottom - WorkTop

            isPrimary := (thisMon == GetVirtualMonitorPrimary()) ? "Yes" : "No"

            infoText .= "--- Virtual Monitor " thisMon " ---`r`n"
            infoText .= "  Primary: " isPrimary " | Resolution: " Width "x" Height "`r`n"
            infoText .= "  Position: X=" Left ", Y=" Top "`r`n"
            infoText .= "  Bounds: Left=" Left ", Right=" Right "`r`n`r`n"
        }
    } else {
        infoText .= "`r`n=== PBP MODE ===`r`n"
        infoText .= "Status: DISABLED`r`n"
        infoText .= "Toggle with: Alt+ScrollLock or Tray Menu`r`n`r`n"
    }

    infoText .= "`r`n=== HOTKEYS ===`r`n"
    infoText .= "Alt+ScrollLock: Toggle PBP Mode`r`n"
    infoText .= "ScrollLock (hold): Show Active Window Info`r`n`r`n"

    ; --- Create a Custom GUI instead of MsgBox ---
    ; Estimate reasonable GUI size (adjust as needed)
    guiWidth := 550
    guiHeight := 300 + (monitorCount * 130) ; Base height + extra per monitor
    if guiHeight > A_ScreenHeight * 0.8 ; Limit max height
        guiHeight := Floor(A_ScreenHeight * 0.8)

    ; Create the GUI window
    InfoGui := Gui("+AlwaysOnTop +Resize", "Connected Monitor Information")
    InfoGui.SetFont("s10", "Consolas") ; Use a monospaced font for better alignment

    ; Add a ReadOnly Edit control to display the text
    ; R = Rows (approximate height), W = Width, ReadOnly makes it non-editable but selectable
    editCtrl := InfoGui.Add("Edit", "w" (guiWidth - 30) " R" (Floor(guiHeight/18)-3) " ReadOnly -VScroll", infoText)

    ; Add an OK button to close the GUI
    buttonYPos := guiHeight - 45
    buttonCtrl := InfoGui.Add("Button", "xm+" (guiWidth/2 - 50) " w100 Default", "OK")
    buttonCtrl.OnEvent("Click", InfoGui_Close)

    ; Function to close the GUI
    InfoGui_Close(*) {
        InfoGui.Destroy()
    }

    ; Handle GUI resize event (optional, but nice)
    InfoGui.OnEvent("Size", InfoGui_Size)
    InfoGui_Size(guiObj, MinMax, Width, Height) {
        ; Resize the Edit control when the GUI is resized
        if IsObject(editCtrl) {
             ; Adjust Edit control width and height relative to GUI size
             ; Leave some margin for borders and the button
            editCtrl.Move(15, 15, Width - 30, Height - 65)
        }
         ; Reposition the OK button
        if IsObject(buttonCtrl) {
            buttonCtrl.Move(Width/2 - 50, Height - 45)
        }
    }


    ; Show the GUI modally (script pauses until it's closed)
    InfoGui.Show("w" guiWidth " h" guiHeight) ; Show with calculated dimensions
}

ShowMonitorInfo() ; Call the function immediately on script start
; --- END: Monitor Information Display on Startup ---

; --- START: PBP Virtual Monitor Toggle ---
ShowPBPNotification(enabled) {
    global pbpSplitX, pbpSplitPercent
    static pbpGui := ""
    static dismissTimer := ""

    ; Destroy old GUI if it exists
    if (pbpGui) {
        try pbpGui.Destroy()
    }

    ; Create notification GUI
    pbpGui := Gui("+ToolWindow -Caption +AlwaysOnTop +E0x20")
    pbpGui.BackColor := "1a1a1a"

    ; Status text with color coding
    if (enabled) {
        ; Get physical monitor dimensions for split calculation
        MonitorGet(1, &PhysLeft, &PhysTop, &PhysRight, &PhysBottom)
        physWidth := PhysRight - PhysLeft
        leftWidth := pbpSplitX
        rightWidth := physWidth - pbpSplitX

        pbpGui.SetFont("s16 c00FF00 Bold", "Segoe UI")
        pbpGui.Add("Text", "x20 y12 w310 c00FF00 Center", "PBP MODE: ON")

        pbpGui.SetFont("s11 cFFFFFF", "Segoe UI")
        pbpGui.Add("Text", "x20 y45 w310 cFFFFFF Center", Round(pbpSplitPercent) "% Split")

        pbpGui.SetFont("s10 cAAAAAA", "Segoe UI")
        pbpGui.Add("Text", "x20 y70 w310 cAAAAAA Center", leftWidth "px  +  " rightWidth "px")

        guiHeight := 105
    } else {
        pbpGui.SetFont("s16 cFF6666 Bold", "Segoe UI")
        pbpGui.Add("Text", "x20 y15 w310 cFF6666 Center", "PBP MODE: OFF")

        pbpGui.SetFont("s10 cAAAAAA", "Segoe UI")
        pbpGui.Add("Text", "x20 y50 w310 cAAAAAA Center", "Using physical monitors")

        guiHeight := 85
    }

    ; Position at center of screen
    pbpGui.Show("x" (A_ScreenWidth/2 - 175) " y" (A_ScreenHeight/2 - 50) " w350 h" guiHeight " NoActivate")
    WinSetTransparent 230, pbpGui.Hwnd

    ; Clear existing timer if any
    if (dismissTimer) {
        SetTimer dismissTimer, 0
    }

    ; Set new auto-dismiss timer
    dismissTimer := () => (pbpGui ? (pbpGui.Destroy(), pbpGui := "") : "")
    SetTimer dismissTimer, -1500
}

TogglePBPFromTray(*) {
    global pbpEnabled
    TogglePBPMode()  ; Call the function from VirtualMonitorManager

    ; Update tray menu check
    if (pbpEnabled) {
        A_TrayMenu.Check "PBP Virtual Monitor"
    } else {
        A_TrayMenu.Uncheck "PBP Virtual Monitor"
    }

    ; Show nice notification
    ShowPBPNotification(pbpEnabled)
}

; Alt+ScrollLock hotkey to toggle PBP mode
!ScrollLock::{
    TogglePBPFromTray()
}

; ScrollLock (held) - Show active window information
ScrollLock::{
    ; Get active window BEFORE creating GUI
    activeWin := WinExist("A")

    if (!activeWin) {
        ToolTip("No active window")
        Sleep 1000
        ToolTip()
        return
    }

    ; Get active window VISUAL position to place overlay (aligns with gold border)
    GetWindowVisualPos("ahk_id " activeWin, &activeX, &activeY, &activeW, &activeH)

    ; Create info overlay GUI (disable DPI scaling and layered window to prevent DWM borders)
    infoGui := Gui("-Caption +ToolWindow +AlwaysOnTop +E0x80000 +E0x20 -DPIScale")
    infoGui.BackColor := "1a1a1a"
    infoGui.SetFont("s10 cWhite", "Consolas")

    ; Use Edit control for multi-line display
    infoText := infoGui.Add("Edit", "x10 y10 w430 h350 ReadOnly -VScroll Background1a1a1a cWhite", "Loading...")

    ; Position overlay at top-right of the active window (offset slightly)
    ; Account for gold border thickness (4px) plus gap
    borderThickness := 4
    overlayWidth := 450
    overlayHeight := 370
    gap := 10

    ; Get monitor bounds using VIRTUAL monitor API (following ShowWindowPositioningGUI pattern)
    VirtualMonitorGetWorkArea(GetWindowMonitor(activeX, activeY, activeW, activeH), &mLeft, &mTop, &mRight, &mBottom)

    ; Calculate potential positions
    rightX := activeX + activeW + borderThickness + gap  ; Right of window
    leftX := activeX - overlayWidth - borderThickness - gap  ; Left of window

    ; Determine horizontal position with fallback logic
    if (rightX + overlayWidth <= mRight) {
        ; Fits on right - preferred position
        overlayX := rightX
    } else if (leftX >= mLeft) {
        ; Fits on left - fallback
        overlayX := leftX
    } else {
        ; Neither side fits - clamp to screen edges
        ; Try right side clamped to screen
        if (mRight - mLeft >= overlayWidth) {
            ; Screen is wide enough for overlay, position at right edge
            overlayX := mRight - overlayWidth
        } else {
            ; Screen narrower than overlay (rare) - align to left edge
            overlayX := mLeft
        }
    }

    ; Determine vertical position - align with window top, clamped to screen
    overlayY := activeY
    if (overlayY + overlayHeight > mBottom) {
        overlayY := mBottom - overlayHeight
    }
    if (overlayY < mTop) {
        overlayY := mTop
    }

    ; Show GUI near the active window
    infoGui.Show("x" overlayX " y" overlayY " w" overlayWidth " h" overlayHeight " NoActivate")
    WinSetTransparent 230, infoGui.Hwnd

    ; Get ACTUAL GUI dimensions (Windows may have added borders/scaling)
    WinGetPos(&actualGuiX, &actualGuiY, &actualGuiW, &actualGuiH, infoGui.Hwnd)

    ; Recalculate position if GUI is wider than expected (e.g., on left side)
    if (overlayX < activeX && actualGuiW > overlayWidth) {
        ; GUI is on left side and wider than expected - adjust to avoid overlap
        overlayX := activeX - actualGuiW - borderThickness - 10
        infoGui.Show("x" overlayX " NoActivate")
    }

    ; Create gold border to show window bounding box
    borderColor := "FFD700"  ; Gold

    ; Create all 4 borders - disable DPI scaling for exact pixel dimensions
    borderTop := Gui("-Caption +ToolWindow +AlwaysOnTop +E0x80000 +E0x20 -DPIScale")
    borderTop.BackColor := borderColor
    WinSetTransparent 255, borderTop.Hwnd

    borderBottom := Gui("-Caption +ToolWindow +AlwaysOnTop +E0x80000 +E0x20 -DPIScale")
    borderBottom.BackColor := borderColor
    WinSetTransparent 255, borderBottom.Hwnd

    borderLeft := Gui("-Caption +ToolWindow +AlwaysOnTop +E0x80000 +E0x20 -DPIScale")
    borderLeft.BackColor := borderColor
    WinSetTransparent 255, borderLeft.Hwnd

    borderRight := Gui("-Caption +ToolWindow +AlwaysOnTop +E0x80000 +E0x20 -DPIScale")
    borderRight.BackColor := borderColor
    WinSetTransparent 255, borderRight.Hwnd

    ; Update info while ScrollLock is held
    while (GetKeyState("ScrollLock", "P")) {
        try {
            ; Get actual visual frame bounds (excludes invisible DWM borders)
            GetWindowVisualPos("ahk_id " activeWin, &wx, &wy, &ww, &wh)

            winClass := WinGetClass("ahk_id " activeWin)
            winTitle := WinGetTitle("ahk_id " activeWin)
            winProcess := WinGetProcessName("ahk_id " activeWin)
            minMax := WinGetMinMax("ahk_id " activeWin)

            ; Update border positions - horizontal bars extend to fill corners
            borderTop.Show("x" . (wx - borderThickness) . " y" . (wy - borderThickness) . " w" . (ww + borderThickness * 2) . " h" . borderThickness . " NoActivate")
            borderBottom.Show("x" . (wx - borderThickness) . " y" . (wy + wh) . " w" . (ww + borderThickness * 2) . " h" . borderThickness . " NoActivate")
            borderLeft.Show("x" . (wx - borderThickness) . " y" . wy . " w" . borderThickness . " h" . wh . " NoActivate")
            borderRight.Show("x" . (wx + ww) . " y" . wy . " w" . borderThickness . " h" . wh . " NoActivate")

            ; Determine monitor (virtual monitor aware)
            monIndex := GetWindowMonitor(wx, wy, ww, wh)

            ; Build info text (use `r`n for Edit controls)
            info := "ACTIVE WINDOW INFO`r`n"
            info .= "════════════════════════════════════`r`n`r`n"
            info .= "Process: " winProcess "`r`n"
            info .= "Title: " SubStr(winTitle, 1, 35) (StrLen(winTitle) > 35 ? "..." : "") "`r`n"
            info .= "Class: " winClass "`r`n`r`n"
            info .= "Position:`r`n"
            info .= "  X: " wx "`r`n"
            info .= "  Y: " wy "`r`n`r`n"
            info .= "Dimensions:`r`n"
            info .= "  Width: " ww "`r`n"
            info .= "  Height: " wh "`r`n`r`n"
            info .= "Edges:`r`n"
            info .= "  Right: " (wx + ww) "`r`n"
            info .= "  Bottom: " (wy + wh) "`r`n`r`n"
            info .= "Monitor: " monIndex

            ; Show min/max state
            if (minMax == 1)
                info .= " (Maximized)"
            else if (minMax == -1)
                info .= " (Minimized)"

            ; Update display
            infoText.Value := info
        } catch as err {
            infoText.Value := "Error: " err.Message
        }

        Sleep 50  ; Update 20 times per second
    }

    ; Cleanup
    infoGui.Destroy()
    borderTop.Destroy()
    borderBottom.Destroy()
    borderLeft.Destroy()
    borderRight.Destroy()
}
; --- END: PBP Virtual Monitor Toggle ---

; --- START: Emergency Key Release (Failsafe) ---
; Pause key - Release all potentially stuck keys
; This is a failsafe for when keys get stuck in pressed state

ShowKeyReleaseNotification() {
    static keyGui := ""
    static dismissTimer := ""

    ; Destroy old GUI if it exists
    if (keyGui) {
        try keyGui.Destroy()
    }

    ; Create notification GUI
    keyGui := Gui("+ToolWindow -Caption +AlwaysOnTop +E0x20")
    keyGui.BackColor := "1a1a1a"

    ; Title
    keyGui.SetFont("s16 c00BFFF Bold", "Segoe UI")
    keyGui.Add("Text", "x20 y15 w260 c00BFFF Center", "KEYS RELEASED")

    ; Subtitle
    keyGui.SetFont("s10 cAAAAAA", "Segoe UI")
    keyGui.Add("Text", "x20 y50 w260 cAAAAAA Center", "All modifiers and buttons reset")

    ; Position at center of screen
    keyGui.Show("x" (A_ScreenWidth/2 - 150) " y" (A_ScreenHeight/2 - 45) " w300 h85 NoActivate")
    WinSetTransparent 230, keyGui.Hwnd

    ; Clear existing timer if any
    if (dismissTimer) {
        SetTimer dismissTimer, 0
    }

    ; Set new auto-dismiss timer
    dismissTimer := () => (keyGui ? (keyGui.Destroy(), keyGui := "") : "")
    SetTimer dismissTimer, -1000
}

; Function to release all keys
ReleaseAllKeys() {
    ; Use SendInput for more reliable key release
    ; SendInput bypasses the keyboard hook and directly injects events

    ; For prefix keys like RAlt, we need to send down+up to fully reset state
    ; This clears AHK's internal "waiting for suffix" state
    SendInput "{RAlt down}{RAlt up}"
    Sleep 10

    ; Release all modifier keys (left and right variants)
    SendInput "{LCtrl up}{RCtrl up}{Ctrl up}"
    SendInput "{LShift up}{RShift up}{Shift up}"
    SendInput "{LAlt up}{RAlt up}{Alt up}"
    SendInput "{LWin up}{RWin up}"

    ; Release mouse buttons
    SendInput "{LButton up}{RButton up}{MButton up}"
    SendInput "{XButton1 up}{XButton2 up}"

    ; Release other common keys that might be involved in hotkeys
    SendInput "{Space up}{Enter up}{Escape up}{Tab up}"
    SendInput "{Backspace up}{Delete up}{Home up}{End up}"
    SendInput "{PgUp up}{PgDn up}{Insert up}"
    SendInput "{Up up}{Down up}{Left up}{Right up}"

    ; Release function keys
    SendInput "{F1 up}{F2 up}{F3 up}{F4 up}{F5 up}{F6 up}"
    SendInput "{F7 up}{F8 up}{F9 up}{F10 up}{F11 up}{F12 up}"

    ; Show nice notification
    ShowKeyReleaseNotification()
}

; Ctrl+Pause hotkey - Direct hotkey for the common case
; Note: Ctrl+Pause generates CtrlBreak, not Ctrl+Pause
^CtrlBreak::ReleaseAllKeys()

; Timer-based approach to ensure it works even when modifiers are stuck
SetTimer CheckPauseKey, 50  ; Check every 50ms

CheckPauseKey() {
    static pauseWasPressed := false

    ; Check if Pause key is currently pressed
    pausePressed := GetKeyState("Pause", "P")

    ; Trigger on key press (rising edge detection)
    if (pausePressed && !pauseWasPressed) {
        ReleaseAllKeys()
    }

    pauseWasPressed := pausePressed
}
; --- END: Emergency Key Release (Failsafe) ---
